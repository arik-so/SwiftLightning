/* Text to put at the beginning of the generated file. Probably a license. */

/* Generated with cbindgen:0.14.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * " Used to give chain error details upstream"
 */
typedef enum {
    /**
     * " Client doesn't support UTXO lookup (but the chain hash matches our genesis block hash)"
     */
    NotSupported,
    /**
     * " Chain isn't the one watched"
     */
    NotWatched,
    /**
     * " Tx doesn't exist or is unconfirmed"
     */
    UnknownTx,
} LDKChainError;

/**
 * " An error enum representing a failure to persist a channel monitor update."
 */
typedef enum {
    /**
     * " Used to indicate a temporary failure (eg connection to a watchtower or remote backup of"
     * " our state failed, but is expected to succeed at some point in the future)."
     * ""
     * " Such a failure will \"freeze\" a channel, preventing us from revoking old states or"
     * " submitting new commitment transactions to the remote party. Once the update(s) which failed"
     * " have been successfully applied, ChannelManager::channel_monitor_updated can be used to"
     * " restore the channel to an operational state."
     * ""
     * " Note that a given ChannelManager will *never* re-generate a given ChannelMonitorUpdate. If"
     * " you return a TemporaryFailure you must ensure that it is written to disk safely before"
     * " writing out the latest ChannelManager state."
     * ""
     * " Even when a channel has been \"frozen\" updates to the ChannelMonitor can continue to occur"
     * " (eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting"
     * " to claim it on this channel) and those updates must be applied wherever they can be. At"
     * " least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should"
     * " be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to"
     * " the channel which would invalidate previous ChannelMonitors are not made when a channel has"
     * " been \"frozen\"."
     * ""
     * " Note that even if updates made after TemporaryFailure succeed you must still call"
     * " channel_monitor_updated to ensure you have the latest monitor and re-enable normal channel"
     * " operation."
     * ""
     * " Note that the update being processed here will not be replayed for you when you call"
     * " ChannelManager::channel_monitor_updated, so you must store the update itself along"
     * " with the persisted ChannelMonitor on your own local disk prior to returning a"
     * " TemporaryFailure. You may, of course, employ a journaling approach, storing only the"
     * " ChannelMonitorUpdate on disk without updating the monitor itself, replaying the journal at"
     * " reload-time."
     * ""
     * " For deployments where a copy of ChannelMonitors and other local state are backed up in a"
     * " remote location (with local copies persisted immediately), it is anticipated that all"
     * " updates will return TemporaryFailure until the remote copies could be updated."
     */
    TemporaryFailure,
    /**
     * " Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a"
     * " different watchtower and cannot update with all watchtowers that were previously informed"
     * " of this channel). This will force-close the channel in question (which will generate one"
     * " final ChannelMonitorUpdate which must be delivered to at least one ChannelMonitor copy)."
     * ""
     * " Should also be used to indicate a failure to update the local persisted copy of the channel"
     * " monitor."
     */
    PermanentFailure,
} LDKChannelMonitorUpdateErr;

/**
 * " An enum that represents the speed at which we want a transaction to confirm used for feerate"
 * " estimation."
 */
typedef enum {
    /**
     * " We are happy with this transaction confirming slowly when feerate drops some."
     */
    Background,
    /**
     * " We'd like this transaction to confirm without major delay, but 12-18 blocks is fine."
     */
    Normal,
    /**
     * " We'd like this transaction to confirm in the next few blocks."
     */
    HighPriority,
} LDKConfirmationTarget;

/**
 * " An enum representing the available verbosity levels of the logger."
 */
typedef enum {
    /**
     * "Designates logger being silent"
     */
    Off,
    /**
     * " Designates very serious errors"
     */
    Error,
    /**
     * " Designates hazardous situations"
     */
    Warn,
    /**
     * " Designates useful information"
     */
    Info,
    /**
     * " Designates lower priority information"
     */
    Debug,
    /**
     * " Designates very low priority, often extremely verbose, information"
     */
    Trace,
} LDKLevel;

typedef enum {
    Bitcoin,
    Testnet,
    Regtest,
} LDKNetwork;

typedef struct {
    uint8_t compact_form[64];
} LDKSignature;

typedef union {
    LDKSignature *result;
    uint8_t *err;
} LDKCResultPtr_Signature__u8;

typedef struct {
    LDKCResultPtr_Signature__u8 contents;
    bool result_good;
} LDKCResultTempl_Signature__u8;

typedef LDKCResultTempl_Signature__u8 LDKCResult_SignatureNoneZ;



/**
 * " Indicates an error on the client's part (usually some variant of attempting to use too-low or"
 * " too-high values)"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnAPIError *inner;
    bool _underlying_ref;
} LDKAPIError;

typedef union {
    uint8_t *result;
    LDKAPIError *err;
} LDKCResultPtr_u8__APIError;

typedef struct {
    LDKCResultPtr_u8__APIError contents;
    bool result_good;
} LDKCResultTempl_u8__APIError;

typedef LDKCResultTempl_u8__APIError LDKCResult_NoneAPIErrorZ;



/**
 * " If a payment fails to send, it can be in one of several states. This enum is returned as the"
 * " Err() type describing which state the payment is in, see the description of individual enum"
 * " states for more."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnPaymentSendFailure *inner;
    bool _underlying_ref;
} LDKPaymentSendFailure;

typedef union {
    uint8_t *result;
    LDKPaymentSendFailure *err;
} LDKCResultPtr_u8__PaymentSendFailure;

typedef struct {
    LDKCResultPtr_u8__PaymentSendFailure contents;
    bool result_good;
} LDKCResultTempl_u8__PaymentSendFailure;

typedef LDKCResultTempl_u8__PaymentSendFailure LDKCResult_NonePaymentSendFailureZ;

typedef union {
    uint8_t *result;
    LDKChannelMonitorUpdateErr *err;
} LDKCResultPtr_u8__ChannelMonitorUpdateErr;

typedef struct {
    LDKCResultPtr_u8__ChannelMonitorUpdateErr contents;
    bool result_good;
} LDKCResultTempl_u8__ChannelMonitorUpdateErr;

typedef LDKCResultTempl_u8__ChannelMonitorUpdateErr LDKCResult_NoneChannelMonitorUpdateErrZ;



/**
 * " Error for PeerManager errors. If you get one of these, you must disconnect the socket and"
 * " generate no further read_event/write_buffer_space_avail calls for the descriptor, only"
 * " triggering a single socket_disconnected call (unless it was provided in response to a"
 * " new_*_connection event, in which case no such socket_disconnected() must be called and the"
 * " socket silently disconencted)."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnPeerHandleError *inner;
    bool _underlying_ref;
} LDKPeerHandleError;

typedef union {
    uint8_t *result;
    LDKPeerHandleError *err;
} LDKCResultPtr_u8__PeerHandleError;

typedef struct {
    LDKCResultPtr_u8__PeerHandleError contents;
    bool result_good;
} LDKCResultTempl_u8__PeerHandleError;

typedef LDKCResultTempl_u8__PeerHandleError LDKCResult_NonePeerHandleErrorZ;



/**
 * " An Event which you should probably take some action in response to."
 * ""
 * " Note that while Writeable and Readable are implemented for Event, you probably shouldn't use"
 * " them directly as they don't round-trip exactly (for example FundingGenerationReady is never"
 * " written as it makes no sense to respond to it after reconnecting to peers)."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnEvent *inner;
    bool _underlying_ref;
} LDKEvent;



/**
 * " An event generated by ChannelManager which indicates a message should be sent to a peer (or"
 * " broadcast to most peers)."
 * " These events are handled by PeerManager::process_events if you are using a PeerManager."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnMessageSendEvent *inner;
    bool _underlying_ref;
} LDKMessageSendEvent;



/**
 * " Top-level config which holds ChannelHandshakeLimits and ChannelConfig."
 * ""
 * " Default::default() provides sane defaults for most configurations"
 * " (but currently with 0 relay fees!)"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnUserConfig *inner;
    bool _underlying_ref;
} LDKUserConfig;



/**
 * " Configuration we set when applicable."
 * ""
 * " Default::default() provides sane defaults."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelHandshakeConfig *inner;
    bool _underlying_ref;
} LDKChannelHandshakeConfig;



/**
 * " Optional channel limits which are applied during channel creation."
 * ""
 * " These limits are only applied to our counterparty's limits, not our own."
 * ""
 * " Use 0/<type>::max_value() as appropriate to skip checking."
 * ""
 * " Provides sane defaults for most configurations."
 * ""
 * " Most additional limits are disabled except those with which specify a default in individual"
 * " field documentation. Note that this may result in barely-usable channels, but since they"
 * " are applied mostly only to incoming channels that's not much of a problem."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelHandshakeLimits *inner;
    bool _underlying_ref;
} LDKChannelHandshakeLimits;



/**
 * " Options which apply on a per-channel basis and may change at runtime or based on negotiation"
 * " with our counterparty."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelConfig *inner;
    bool _underlying_ref;
} LDKChannelConfig;



/**
 * " Utility for tracking registered txn/outpoints and checking for matches"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChainWatchedUtil *inner;
    bool _underlying_ref;
} LDKChainWatchedUtil;

typedef struct {
    const uint8_t *data;
    uintptr_t datalen;
} LDKu8slice;

/**
 * Arbitrary 32 bytes, which could represent one of a few different things. You probably want to
 * look up the corresponding function in rust-lightning's docs.
 */
typedef struct {
    uint8_t data[32];
} LDKThirtyTwoBytes;

typedef struct {
    LDKThirtyTwoBytes *a;
    uint32_t *b;
} LDKC2TupleTempl_ThirtyTwoBytes__u32;

typedef LDKC2TupleTempl_ThirtyTwoBytes__u32 LDKC2Tuple_Txidu32Z;

/**
 * A reference to a serialized transaction, in (pointer, length) form.
 * This type does *not* own its own memory, so access to it after, eg, the call in which it was
 * provided to you are invalid.
 */
typedef struct {
    const uint8_t *data;
    uintptr_t datalen;
} LDKTransaction;

/**
 * " A trait indicating a desire to listen for events from the chain"
 */
typedef struct {
    void *this_arg;
    /**
     * " Notifies a listener that a block was disconnected."
     * " Unlike block_connected, this *must* never be called twice for the same disconnect event."
     * " Height must be the one of the block which was disconnected (not new height of the best chain)"
     */
    void (*block_disconnected)(const void *this_arg, const uint8_t (*header)[80], uint32_t disconnected_height);
} LDKChainListener;

typedef struct {
    uint8_t *data;
    uintptr_t datalen;
} LDKCVecTempl_u8;

typedef LDKCVecTempl_u8 LDKCVec_u8Z;

typedef struct {
    LDKCVec_u8Z *a;
    uint64_t *b;
} LDKC2TupleTempl_CVec_u8Z__u64;

typedef union {
    LDKC2TupleTempl_CVec_u8Z__u64 *result;
    LDKChainError *err;
} LDKCResultPtr_C2TupleTempl_CVec_u8Z__u64_____ChainError;

typedef struct {
    LDKCResultPtr_C2TupleTempl_CVec_u8Z__u64_____ChainError contents;
    bool result_good;
} LDKCResultTempl_C2TupleTempl_CVec_u8Z__u64_____ChainError;

typedef LDKCResultTempl_C2TupleTempl_CVec_u8Z__u64_____ChainError LDKCResult_C2Tuple_Scriptu64ZChainErrorZ;

/**
 * " An interface to request notification of certain scripts as they appear the"
 * " chain."
 * ""
 * " Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're"
 * " called from inside the library in response to ChainListener events, P2P events, or timer"
 * " events)."
 */
typedef struct {
    void *this_arg;
    /**
     * " Provides a txid/random-scriptPubKey-in-the-tx which much be watched for."
     */
    void (*install_watch_tx)(const void *this_arg, const uint8_t (*txid)[32], LDKu8slice script_pub_key);
    /**
     * " Provides an outpoint which must be watched for, providing any transactions which spend the"
     * " given outpoint."
     */
    void (*install_watch_outpoint)(const void *this_arg, LDKC2Tuple_Txidu32Z outpoint, LDKu8slice out_script);
    /**
     * " Indicates that a listener needs to see all transactions."
     */
    void (*watch_all_txn)(const void *this_arg);
    /**
     * " Gets the script and value in satoshis for a given unspent transaction output given a"
     * " short_channel_id (aka unspent_tx_output_identier). For BTC/tBTC channels the top three"
     * " bytes are the block height, the next 3 the transaction index within the block, and the"
     * " final two the output within the transaction."
     */
    LDKCResult_C2Tuple_Scriptu64ZChainErrorZ (*get_chain_utxo)(const void *this_arg, uint8_t genesis_hash[32], uint64_t unspent_tx_output_identifier);
    /**
     * " Returns a usize that changes when the ChainWatchInterface's watched data is modified."
     * " Users of `filter_block` should pre-save a copy of `reentered`'s return value and use it to"
     * " determine whether they need to re-filter a given block."
     */
    uintptr_t (*reentered)(const void *this_arg);
} LDKChainWatchInterface;



/**
 * " Utility for notifying listeners about new blocks, and handling block rescans if new watch"
 * " data is registered."
 * ""
 * " Rather than using a plain BlockNotifier, it is preferable to use either a BlockNotifierArc"
 * " or a BlockNotifierRef for conciseness. See their documentation for more details, but essentially"
 * " you should default to using a BlockNotifierRef, and use a BlockNotifierArc instead when you"
 * " require ChainListeners with static lifetimes, such as when you're using lightning-net-tokio."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnBlockNotifier *inner;
    bool _underlying_ref;
} LDKBlockNotifier;



/**
 * " Utility to capture some common parts of ChainWatchInterface implementors."
 * ""
 * " Keeping a local copy of this in a ChainWatchInterface implementor is likely useful."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChainWatchInterfaceUtil *inner;
    bool _underlying_ref;
} LDKChainWatchInterfaceUtil;



/**
 * " A reference to a transaction output."
 * ""
 * " Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32"
 * " due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnOutPoint *inner;
    bool _underlying_ref;
} LDKOutPoint;



/**
 * " When on-chain outputs are created by rust-lightning (which our counterparty is not able to"
 * " claim at any point in the future) an event is generated which you must track and be able to"
 * " spend on-chain. The information needed to do this is provided in this enum, including the"
 * " outpoint describing which txid and output index is available, the full output which exists at"
 * " that txid/index, and any keys or other information required to sign."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnSpendableOutputDescriptor *inner;
    bool _underlying_ref;
} LDKSpendableOutputDescriptor;



/**
 * " A simple implementation of ChannelKeys that just keeps the private keys in memory."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnInMemoryChannelKeys *inner;
    bool _underlying_ref;
} LDKInMemoryChannelKeys;

typedef struct {
    uint8_t bytes[32];
} LDKSecretKey;



/**
 * " One counterparty's public keys which do not change over the life of a channel."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelPublicKeys *inner;
    bool _underlying_ref;
} LDKChannelPublicKeys;

/**
 * " Set of lightning keys needed to operate a channel as described in BOLT 3."
 * ""
 * " Signing services could be implemented on a hardware wallet. In this case,"
 * " the current ChannelKeys would be a front-end on top of a communication"
 * " channel connected to your secure device and lightning key material wouldn't"
 * " reside on a hot server. Nevertheless, a this deployment would still need"
 * " to trust the ChannelManager to avoid loss of funds as this latest component"
 * " could ask to sign commitment transaction with HTLCs paying to attacker pubkeys."
 * ""
 * " A more secure iteration would be to use hashlock (or payment points) to pair"
 * " invoice/incoming HTLCs with outgoing HTLCs to implement a no-trust-ChannelManager"
 * " at the price of more state and computation on the hardware wallet side. In the future,"
 * " we are looking forward to design such interface."
 * ""
 * " In any case, ChannelMonitor or fallback watchtowers are always going to be trusted"
 * " to act, as liveness and breach reply correctness are always going to be hard requirements"
 * " of LN security model, orthogonal of key management issues."
 * ""
 * " If you're implementing a custom signer, you almost certainly want to implement"
 * " Readable/Writable to serialize out a unique reference to this set of keys so"
 * " that you can serialize the full ChannelManager object."
 * ""
 */
typedef struct {
    void *this_arg;
    /**
     * " Create a signature for a (proposed) closing transaction."
     * ""
     * " Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have"
     * " chosen to forgo their output as dust."
     */
    LDKCResult_SignatureNoneZ (*sign_closing_transaction)(const void *this_arg, LDKTransaction closing_tx);
    /**
     * " Set the remote channel basepoints.  This is done immediately on incoming channels"
     * " and as soon as the channel is accepted on outgoing channels."
     * ""
     * " Will be called before any signatures are applied."
     */
    void (*set_remote_channel_pubkeys)(void *this_arg, const LDKChannelPublicKeys *channel_points);
} LDKChannelKeys;



/**
 * " Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key"
 * " and derives keys from that."
 * ""
 * " Your node_id is seed/0'"
 * " ChannelMonitor closes may use seed/1'"
 * " Cooperative closes may use seed/2'"
 * " The two close keys may be needed to claim on-chain funds!"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnKeysManager *inner;
    bool _underlying_ref;
} LDKKeysManager;

typedef struct {
    uint8_t compressed_form[33];
} LDKPublicKey;

typedef struct {
    LDKSecretKey *a;
    LDKThirtyTwoBytes *b;
} LDKC2TupleTempl_SecretKey__ThirtyTwoBytes;

typedef LDKC2TupleTempl_SecretKey__ThirtyTwoBytes LDKC2Tuple_SecretKey_u832Z;

/**
 * " A trait to describe an object which can get user secrets and key material."
 */
typedef struct {
    void *this_arg;
    /**
     * " Get node secret key (aka node_id or network_key)"
     */
    LDKSecretKey (*get_node_secret)(const void *this_arg);
    /**
     * " Get destination redeemScript to encumber static protocol exit points."
     */
    LDKCVec_u8Z (*get_destination_script)(const void *this_arg);
    /**
     * " Get shutdown_pubkey to use as PublicKey at channel closure"
     */
    LDKPublicKey (*get_shutdown_pubkey)(const void *this_arg);
    /**
     * " Get a new set of ChannelKeys for per-channel secrets. These MUST be unique even if you"
     * " restarted with some stale data!"
     */
    LDKChannelKeys (*get_channel_keys)(const void *this_arg, bool inbound, uint64_t channel_value_satoshis);
    /**
     * " Get a secret and PRNG seed for constructing an onion packet"
     */
    LDKC2Tuple_SecretKey_u832Z (*get_onion_rand)(const void *this_arg);
    /**
     * " Get a unique temporary channel id. Channels will be referred to by this until the funding"
     * " transaction is created, at which point they will use the outpoint in the funding"
     * " transaction."
     */
    LDKThirtyTwoBytes (*get_channel_id)(const void *this_arg);
} LDKKeysInterface;



/**
 * " A ChannelMonitor handles chain events (blocks connected and disconnected) and generates"
 * " on-chain transactions to ensure no loss of funds occurs."
 * ""
 * " You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date"
 * " information and are actively monitoring the chain."
 * ""
 * " Pending Events or updated HTLCs which have not yet been read out by"
 * " get_and_clear_pending_htlcs_updated or get_and_clear_pending_events are serialized to disk and"
 * " reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events"
 * " gotten are fully handled before re-serializing the new state."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelMonitor *inner;
    bool _underlying_ref;
} LDKChannelMonitor;



/**
 * " An update generated by the underlying Channel itself which contains some new information the"
 * " ChannelMonitor should be made aware of."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelMonitorUpdate *inner;
    bool _underlying_ref;
} LDKChannelMonitorUpdate;



/**
 * " Simple structure send back by ManyChannelMonitor in case of HTLC detected onchain from a"
 * " forward channel and from which info are needed to update HTLC in a backward channel."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnHTLCUpdate *inner;
    bool _underlying_ref;
} LDKHTLCUpdate;

typedef struct {
    LDKHTLCUpdate *data;
    uintptr_t datalen;
} LDKCVecTempl_HTLCUpdate;

typedef LDKCVecTempl_HTLCUpdate LDKCVec_HTLCUpdateZ;

/**
 * " Simple trait indicating ability to track a set of ChannelMonitors and multiplex events between"
 * " them. Generally should be implemented by keeping a local SimpleManyChannelMonitor and passing"
 * " events to it, while also taking any add/update_monitor events and passing them to some remote"
 * " server(s)."
 * ""
 * " In general, you must always have at least one local copy in memory, which must never fail to"
 * " update (as it is responsible for broadcasting the latest state in case the channel is closed),"
 * " and then persist it to various on-disk locations. If, for some reason, the in-memory copy fails"
 * " to update (eg out-of-memory or some other condition), you must immediately shut down without"
 * " taking any further action such as writing the current state to disk. This should likely be"
 * " accomplished via panic!() or abort()."
 * ""
 * " Note that any updates to a channel's monitor *must* be applied to each instance of the"
 * " channel's monitor everywhere (including remote watchtowers) *before* this function returns. If"
 * " an update occurs and a remote watchtower is left with old state, it may broadcast transactions"
 * " which we have revoked, allowing our counterparty to claim all funds in the channel!"
 * ""
 * " User needs to notify implementors of ManyChannelMonitor when a new block is connected or"
 * " disconnected using their `block_connected` and `block_disconnected` methods. However, rather"
 * " than calling these methods directly, the user should register implementors as listeners to the"
 * " BlockNotifier and call the BlockNotifier's `block_(dis)connected` methods, which will notify"
 * " all registered listeners in one go."
 */
typedef struct {
    void *this_arg;
    /**
     * " Adds a monitor for the given `funding_txo`."
     * ""
     * " Implementer must also ensure that the funding_txo txid *and* outpoint are registered with"
     * " any relevant ChainWatchInterfaces such that the provided monitor receives block_connected"
     * " callbacks with the funding transaction, or any spends of it."
     * ""
     * " Further, the implementer must also ensure that each output returned in"
     * " monitor.get_outputs_to_watch() is registered to ensure that the provided monitor learns about"
     * " any spends of any of the outputs."
     * ""
     * " Any spends of outputs which should have been registered which aren't passed to"
     * " ChannelMonitors via block_connected may result in FUNDS LOSS."
     */
    LDKCResult_NoneChannelMonitorUpdateErrZ (*add_monitor)(const void *this_arg, LDKOutPoint funding_txo, LDKChannelMonitor monitor);
    /**
     * " Updates a monitor for the given `funding_txo`."
     * ""
     * " Implementer must also ensure that the funding_txo txid *and* outpoint are registered with"
     * " any relevant ChainWatchInterfaces such that the provided monitor receives block_connected"
     * " callbacks with the funding transaction, or any spends of it."
     * ""
     * " Further, the implementer must also ensure that each output returned in"
     * " monitor.get_watch_outputs() is registered to ensure that the provided monitor learns about"
     * " any spends of any of the outputs."
     * ""
     * " Any spends of outputs which should have been registered which aren't passed to"
     * " ChannelMonitors via block_connected may result in FUNDS LOSS."
     */
    LDKCResult_NoneChannelMonitorUpdateErrZ (*update_monitor)(const void *this_arg, LDKOutPoint funding_txo, LDKChannelMonitorUpdate monitor);
    /**
     * " Used by ChannelManager to get list of HTLC resolved onchain and which needed to be updated"
     * " with success or failure."
     * ""
     * " You should probably just call through to"
     * " ChannelMonitor::get_and_clear_pending_htlcs_updated() for each ChannelMonitor and return"
     * " the full list."
     */
    LDKCVec_HTLCUpdateZ (*get_and_clear_pending_htlcs_updated)(const void *this_arg);
} LDKManyChannelMonitor;

/**
 * " An interface to send a transaction to the Bitcoin network."
 */
typedef struct {
    void *this_arg;
    /**
     * " Sends a transaction out to (hopefully) be mined."
     */
    void (*broadcast_transaction)(const void *this_arg, LDKTransaction tx);
} LDKBroadcasterInterface;

/**
 * " A trait which should be implemented to provide feerate information on a number of time"
 * " horizons."
 * ""
 * " Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're"
 * " called from inside the library in response to ChainListener events, P2P events, or timer"
 * " events)."
 */
typedef struct {
    void *this_arg;
    /**
     * " Gets estimated satoshis of fee required per 1000 Weight-Units."
     * ""
     * " Must be no smaller than 253 (ie 1 satoshi-per-byte rounded up to ensure later round-downs"
     * " don't put us below 1 satoshi-per-byte)."
     * ""
     * " This translates to:"
     * "  * satoshis-per-byte * 250"
     * "  * ceil(satoshis-per-kbyte / 4)"
     */
    uint64_t (*get_est_sat_per_1000_weight)(const void *this_arg, LDKConfirmationTarget confirmation_target);
} LDKFeeEstimator;

/**
 * " A trait encapsulating the operations required of a logger"
 */
typedef struct {
    void *this_arg;
    /**
     * " Logs the `Record`"
     */
    void (*log)(const void *this_arg, const char *record);
} LDKLogger;



/**
 * " Manager which keeps track of a number of channels and sends messages to the appropriate"
 * " channel, also tracking HTLC preimages and forwarding onion packets appropriately."
 * ""
 * " Implements ChannelMessageHandler, handling the multi-channel parts and passing things through"
 * " to individual Channels."
 * ""
 * " Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for"
 * " all peers during write/read (though does not modify this instance, only the instance being"
 * " serialized). This will result in any channels which have not yet exchanged funding_created (ie"
 * " called funding_transaction_generated for outbound channels)."
 * ""
 * " Note that you can be a bit lazier about writing out ChannelManager than you can be with"
 * " ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before"
 * " returning from ManyChannelMonitor::add_/update_monitor, with ChannelManagers, writing updates"
 * " happens out-of-band (and will prevent any other ChannelManager operations from occurring during"
 * " the serialization process). If the deserialized version is out-of-date compared to the"
 * " ChannelMonitors passed by reference to read(), those channels will be force-closed based on the"
 * " ChannelMonitor state and no funds will be lost (mod on-chain transaction fees)."
 * ""
 * " Note that the deserializer is only implemented for (Sha256dHash, ChannelManager), which"
 * " tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along"
 * " the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call"
 * " block_connected() to step towards your best block) upon deserialization before using the"
 * " object!"
 * ""
 * " Note that ChannelManager is responsible for tracking liveness of its channels and generating"
 * " ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid"
 * " spam due to quick disconnection/reconnection, updates are not sent until the channel has been"
 * " offline for a full minute. In order to track this, you must call"
 * " timer_chan_freshness_every_min roughly once per minute, though it doesn't have to be perfect."
 * ""
 * " Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager"
 * " a SimpleRefChannelManager, for conciseness. See their documentation for more details, but"
 * " essentially you should default to using a SimpleRefChannelManager, and use a"
 * " SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when"
 * " you're using lightning-net-tokio."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelManager *inner;
    bool _underlying_ref;
} LDKChannelManager;



/**
 * " Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelDetails *inner;
    bool _underlying_ref;
} LDKChannelDetails;



/**
 * " Features used within an `init` message."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnInitFeatures *inner;
    bool _underlying_ref;
} LDKInitFeatures;

typedef struct {
    LDKChannelDetails *data;
    uintptr_t datalen;
} LDKCVecTempl_ChannelDetails;

typedef LDKCVecTempl_ChannelDetails LDKCVec_ChannelDetailsZ;



/**
 * " A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,"
 * " it can take multiple paths. Each path is composed of one or more hops through the network."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnRoute *inner;
    bool _underlying_ref;
} LDKRoute;

typedef struct {
    uint8_t data[3];
} LDKThreeBytes;



/**
 * " An address which can be used to connect to a remote peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnNetAddress *inner;
    bool _underlying_ref;
} LDKNetAddress;

typedef struct {
    LDKNetAddress *data;
    uintptr_t datalen;
} LDKCVecTempl_NetAddress;

typedef LDKCVecTempl_NetAddress LDKCVec_NetAddressZ;

typedef struct {
    LDKEvent *data;
    uintptr_t datalen;
} LDKCVecTempl_Event;

typedef LDKCVecTempl_Event LDKCVec_EventZ;

/**
 * " A trait indicating an object may generate events"
 */
typedef struct {
    void *this_arg;
    /**
     * " Gets the list of pending events which were generated by previous actions, clearing the list"
     * " in the process."
     */
    LDKCVec_EventZ (*get_and_clear_pending_events)(const void *this_arg);
} LDKEventsProvider;



/**
 * " An open_channel message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnOpenChannel *inner;
    bool _underlying_ref;
} LDKOpenChannel;



/**
 * " An accept_channel message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnAcceptChannel *inner;
    bool _underlying_ref;
} LDKAcceptChannel;



/**
 * " A funding_created message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnFundingCreated *inner;
    bool _underlying_ref;
} LDKFundingCreated;



/**
 * " A funding_signed message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnFundingSigned *inner;
    bool _underlying_ref;
} LDKFundingSigned;



/**
 * " A funding_locked message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnFundingLocked *inner;
    bool _underlying_ref;
} LDKFundingLocked;



/**
 * " A shutdown message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnShutdown *inner;
    bool _underlying_ref;
} LDKShutdown;



/**
 * " A closing_signed message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnClosingSigned *inner;
    bool _underlying_ref;
} LDKClosingSigned;



/**
 * " An update_add_htlc message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnUpdateAddHTLC *inner;
    bool _underlying_ref;
} LDKUpdateAddHTLC;



/**
 * " An update_fulfill_htlc message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnUpdateFulfillHTLC *inner;
    bool _underlying_ref;
} LDKUpdateFulfillHTLC;



/**
 * " An update_fail_htlc message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnUpdateFailHTLC *inner;
    bool _underlying_ref;
} LDKUpdateFailHTLC;



/**
 * " An update_fail_malformed_htlc message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnUpdateFailMalformedHTLC *inner;
    bool _underlying_ref;
} LDKUpdateFailMalformedHTLC;



/**
 * " A commitment_signed message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnCommitmentSigned *inner;
    bool _underlying_ref;
} LDKCommitmentSigned;



/**
 * " A revoke_and_ack message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnRevokeAndACK *inner;
    bool _underlying_ref;
} LDKRevokeAndACK;



/**
 * " An update_fee message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnUpdateFee *inner;
    bool _underlying_ref;
} LDKUpdateFee;



/**
 * " An announcement_signatures message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnAnnouncementSignatures *inner;
    bool _underlying_ref;
} LDKAnnouncementSignatures;



/**
 * " An init message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnInit *inner;
    bool _underlying_ref;
} LDKInit;



/**
 * " A channel_reestablish message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelReestablish *inner;
    bool _underlying_ref;
} LDKChannelReestablish;



/**
 * " An error message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnErrorMessage *inner;
    bool _underlying_ref;
} LDKErrorMessage;

typedef struct {
    LDKMessageSendEvent *data;
    uintptr_t datalen;
} LDKCVecTempl_MessageSendEvent;

typedef LDKCVecTempl_MessageSendEvent LDKCVec_MessageSendEventZ;

/**
 * " A trait indicating an object may generate message send events"
 */
typedef struct {
    void *this_arg;
    /**
     * " Gets the list of pending events which were generated by previous actions, clearing the list"
     * " in the process."
     */
    LDKCVec_MessageSendEventZ (*get_and_clear_pending_msg_events)(const void *this_arg);
} LDKMessageSendEventsProvider;

/**
 * " A trait to describe an object which can receive channel messages."
 * ""
 * " Messages MAY be called in parallel when they originate from different their_node_ids, however"
 * " they MUST NOT be called in parallel when the two calls have the same their_node_id."
 */
typedef struct {
    void *this_arg;
    /**
     * " Handle an incoming open_channel message from the given peer."
     */
    void (*handle_open_channel)(const void *this_arg, LDKPublicKey their_node_id, LDKInitFeatures their_features, const LDKOpenChannel *msg);
    /**
     * " Handle an incoming accept_channel message from the given peer."
     */
    void (*handle_accept_channel)(const void *this_arg, LDKPublicKey their_node_id, LDKInitFeatures their_features, const LDKAcceptChannel *msg);
    /**
     * " Handle an incoming funding_created message from the given peer."
     */
    void (*handle_funding_created)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingCreated *msg);
    /**
     * " Handle an incoming funding_signed message from the given peer."
     */
    void (*handle_funding_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingSigned *msg);
    /**
     * " Handle an incoming funding_locked message from the given peer."
     */
    void (*handle_funding_locked)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingLocked *msg);
    /**
     * " Handle an incoming shutdown message from the given peer."
     */
    void (*handle_shutdown)(const void *this_arg, LDKPublicKey their_node_id, const LDKShutdown *msg);
    /**
     * " Handle an incoming closing_signed message from the given peer."
     */
    void (*handle_closing_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKClosingSigned *msg);
    /**
     * " Handle an incoming update_add_htlc message from the given peer."
     */
    void (*handle_update_add_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateAddHTLC *msg);
    /**
     * " Handle an incoming update_fulfill_htlc message from the given peer."
     */
    void (*handle_update_fulfill_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFulfillHTLC *msg);
    /**
     * " Handle an incoming update_fail_htlc message from the given peer."
     */
    void (*handle_update_fail_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFailHTLC *msg);
    /**
     * " Handle an incoming update_fail_malformed_htlc message from the given peer."
     */
    void (*handle_update_fail_malformed_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFailMalformedHTLC *msg);
    /**
     * " Handle an incoming commitment_signed message from the given peer."
     */
    void (*handle_commitment_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKCommitmentSigned *msg);
    /**
     * " Handle an incoming revoke_and_ack message from the given peer."
     */
    void (*handle_revoke_and_ack)(const void *this_arg, LDKPublicKey their_node_id, const LDKRevokeAndACK *msg);
    /**
     * " Handle an incoming update_fee message from the given peer."
     */
    void (*handle_update_fee)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFee *msg);
    /**
     * " Handle an incoming announcement_signatures message from the given peer."
     */
    void (*handle_announcement_signatures)(const void *this_arg, LDKPublicKey their_node_id, const LDKAnnouncementSignatures *msg);
    /**
     * " Indicates a connection to the peer failed/an existing connection was lost. If no connection"
     * " is believed to be possible in the future (eg they're sending us messages we don't"
     * " understand or indicate they require unknown feature bits), no_connection_possible is set"
     * " and any outstanding channels should be failed."
     */
    void (*peer_disconnected)(const void *this_arg, LDKPublicKey their_node_id, bool no_connection_possible);
    /**
     * " Handle a peer reconnecting, possibly generating channel_reestablish message(s)."
     */
    void (*peer_connected)(const void *this_arg, LDKPublicKey their_node_id, const LDKInit *msg);
    /**
     * " Handle an incoming channel_reestablish message from the given peer."
     */
    void (*handle_channel_reestablish)(const void *this_arg, LDKPublicKey their_node_id, const LDKChannelReestablish *msg);
    /**
     * " Handle an incoming error message from the given peer."
     */
    void (*handle_error)(const void *this_arg, LDKPublicKey their_node_id, const LDKErrorMessage *msg);
    LDKMessageSendEventsProvider MessageSendEventsProvider;
} LDKChannelMessageHandler;



/**
 * " General Err type for ChannelMonitor actions. Generally, this implies that the data provided is"
 * " inconsistent with the ChannelMonitor being called. eg for ChannelMonitor::update_monitor this"
 * " means you tried to update a monitor for a different channel or the ChannelMonitorUpdate was"
 * " corrupted."
 * " Contains a human-readable error message."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnMonitorUpdateError *inner;
    bool _underlying_ref;
} LDKMonitorUpdateError;



/**
 * " An error in decoding a message or struct."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnDecodeError *inner;
    bool _underlying_ref;
} LDKDecodeError;



/**
 * " A ping message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnPing *inner;
    bool _underlying_ref;
} LDKPing;



/**
 * " A pong message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnPong *inner;
    bool _underlying_ref;
} LDKPong;



/**
 * " The unsigned part of a node_announcement"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnUnsignedNodeAnnouncement *inner;
    bool _underlying_ref;
} LDKUnsignedNodeAnnouncement;



/**
 * " A node_announcement message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnNodeAnnouncement *inner;
    bool _underlying_ref;
} LDKNodeAnnouncement;



/**
 * " The unsigned part of a channel_announcement"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnUnsignedChannelAnnouncement *inner;
    bool _underlying_ref;
} LDKUnsignedChannelAnnouncement;



/**
 * " A channel_announcement message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelAnnouncement *inner;
    bool _underlying_ref;
} LDKChannelAnnouncement;



/**
 * " A channel_update message to be sent or received from a peer"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelUpdate *inner;
    bool _underlying_ref;
} LDKChannelUpdate;



/**
 * " An Err type for failure to process messages."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnLightningError *inner;
    bool _underlying_ref;
} LDKLightningError;



/**
 * " Struct used to return values from revoke_and_ack messages, containing a bunch of commitment"
 * " transaction updates if they were pending."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnCommitmentUpdate *inner;
    bool _underlying_ref;
} LDKCommitmentUpdate;

typedef struct {
    LDKUpdateAddHTLC *data;
    uintptr_t datalen;
} LDKCVecTempl_UpdateAddHTLC;

typedef LDKCVecTempl_UpdateAddHTLC LDKCVec_UpdateAddHTLCZ;

typedef struct {
    LDKUpdateFulfillHTLC *data;
    uintptr_t datalen;
} LDKCVecTempl_UpdateFulfillHTLC;

typedef LDKCVecTempl_UpdateFulfillHTLC LDKCVec_UpdateFulfillHTLCZ;

typedef struct {
    LDKUpdateFailHTLC *data;
    uintptr_t datalen;
} LDKCVecTempl_UpdateFailHTLC;

typedef LDKCVecTempl_UpdateFailHTLC LDKCVec_UpdateFailHTLCZ;

typedef struct {
    LDKUpdateFailMalformedHTLC *data;
    uintptr_t datalen;
} LDKCVecTempl_UpdateFailMalformedHTLC;

typedef LDKCVecTempl_UpdateFailMalformedHTLC LDKCVec_UpdateFailMalformedHTLCZ;



/**
 * " The information we received from a peer along the route of a payment we originated. This is"
 * " returned by ChannelMessageHandler::handle_update_fail_htlc to be passed into"
 * " RoutingMessageHandler::handle_htlc_fail_channel_update to update our network map."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnHTLCFailChannelUpdate *inner;
    bool _underlying_ref;
} LDKHTLCFailChannelUpdate;

typedef union {
    bool *result;
    LDKLightningError *err;
} LDKCResultPtr_bool__LightningError;

typedef struct {
    LDKCResultPtr_bool__LightningError contents;
    bool result_good;
} LDKCResultTempl_bool__LightningError;

typedef LDKCResultTempl_bool__LightningError LDKCResult_boolLightningErrorZ;

/**
 * " A trait to describe an object which can receive routing messages."
 */
typedef struct {
    void *this_arg;
    /**
     * " Handle an incoming node_announcement message, returning true if it should be forwarded on,"
     * " false or returning an Err otherwise."
     */
    LDKCResult_boolLightningErrorZ (*handle_node_announcement)(const void *this_arg, const LDKNodeAnnouncement *msg);
    /**
     * " Handle a channel_announcement message, returning true if it should be forwarded on, false"
     * " or returning an Err otherwise."
     */
    LDKCResult_boolLightningErrorZ (*handle_channel_announcement)(const void *this_arg, const LDKChannelAnnouncement *msg);
    /**
     * " Handle an incoming channel_update message, returning true if it should be forwarded on,"
     * " false or returning an Err otherwise."
     */
    LDKCResult_boolLightningErrorZ (*handle_channel_update)(const void *this_arg, const LDKChannelUpdate *msg);
    /**
     * " Handle some updates to the route graph that we learned due to an outbound failed payment."
     */
    void (*handle_htlc_fail_channel_update)(const void *this_arg, const LDKHTLCFailChannelUpdate *update);
    /**
     * " Returns whether a full sync should be requested from a peer."
     */
    bool (*should_request_full_sync)(const void *this_arg, LDKPublicKey node_id);
} LDKRoutingMessageHandler;



/**
 * " Provides references to trait impls which handle different types of messages."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnMessageHandler *inner;
    bool _underlying_ref;
} LDKMessageHandler;

/**
 * " Provides an object which can be used to send data to and which uniquely identifies a connection"
 * " to a remote host. You will need to be able to generate multiple of these which meet Eq and"
 * " implement Hash to meet the PeerManager API."
 * ""
 * " For efficiency, Clone should be relatively cheap for this type."
 * ""
 * " You probably want to just extend an int and put a file descriptor in a struct and implement"
 * " send_data. Note that if you are using a higher-level net library that may call close() itself,"
 * " be careful to ensure you don't have races whereby you might register a new connection with an"
 * " fd which is the same as a previous one which has yet to be removed via"
 * " PeerManager::socket_disconnected()."
 */
typedef struct {
    void *this_arg;
    /**
     * " Attempts to send some data from the given slice to the peer."
     * ""
     * " Returns the amount of data which was sent, possibly 0 if the socket has since disconnected."
     * " Note that in the disconnected case, socket_disconnected must still fire and further write"
     * " attempts may occur until that time."
     * ""
     * " If the returned size is smaller than data.len(), a write_available event must"
     * " trigger the next time more data can be written. Additionally, until the a send_data event"
     * " completes fully, no further read_events should trigger on the same peer!"
     * ""
     * " If a read_event on this descriptor had previously returned true (indicating that read"
     * " events should be paused to prevent DoS in the send buffer), resume_read may be set"
     * " indicating that read events on this descriptor should resume. A resume_read of false does"
     * " *not* imply that further read events should be paused."
     */
    uintptr_t (*send_data)(void *this_arg, LDKu8slice data, bool resume_read);
    /**
     * " Disconnect the socket pointed to by this SocketDescriptor. Once this function returns, no"
     * " more calls to write_buffer_space_avail, read_event or socket_disconnected may be made with"
     * " this descriptor. No socket_disconnected call should be generated as a result of this call,"
     * " though races may occur whereby disconnect_socket is called after a call to"
     * " socket_disconnected but prior to socket_disconnected returning."
     */
    void (*disconnect_socket)(void *this_arg);
    bool (*eq)(const void *this_arg, const void *other_arg);
    uint64_t (*hash)(const void *this_arg);
} LDKSocketDescriptor;



/**
 * " A PeerManager manages a set of peers, described by their SocketDescriptor and marshalls socket"
 * " events into messages which it passes on to its MessageHandlers."
 * ""
 * " Rather than using a plain PeerManager, it is preferable to use either a SimpleArcPeerManager"
 * " a SimpleRefPeerManager, for conciseness. See their documentation for more details, but"
 * " essentially you should default to using a SimpleRefPeerManager, and use a"
 * " SimpleArcPeerManager when you require a PeerManager with a static lifetime, such as when"
 * " you're using lightning-net-tokio."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnPeerManager *inner;
    bool _underlying_ref;
} LDKPeerManager;

typedef struct {
    LDKPublicKey *data;
    uintptr_t datalen;
} LDKCVecTempl_PublicKey;

typedef LDKCVecTempl_PublicKey LDKCVec_PublicKeyZ;

typedef union {
    LDKCVecTempl_u8 *result;
    LDKPeerHandleError *err;
} LDKCResultPtr_CVecTempl_u8_____PeerHandleError;

typedef struct {
    LDKCResultPtr_CVecTempl_u8_____PeerHandleError contents;
    bool result_good;
} LDKCResultTempl_CVecTempl_u8_____PeerHandleError;

typedef LDKCResultTempl_CVecTempl_u8_____PeerHandleError LDKCResult_CVec_u8ZPeerHandleErrorZ;

typedef union {
    bool *result;
    LDKPeerHandleError *err;
} LDKCResultPtr_bool__PeerHandleError;

typedef struct {
    LDKCResultPtr_bool__PeerHandleError contents;
    bool result_good;
} LDKCResultTempl_bool__PeerHandleError;

typedef LDKCResultTempl_bool__PeerHandleError LDKCResult_boolPeerHandleErrorZ;



/**
 * " The set of public keys which are used in the creation of one commitment transaction."
 * " These are derived from the channel base keys and per-commitment data."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnTxCreationKeys *inner;
    bool _underlying_ref;
} LDKTxCreationKeys;



/**
 * " Information about an HTLC as it appears in a commitment transaction"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnHTLCOutputInCommitment *inner;
    bool _underlying_ref;
} LDKHTLCOutputInCommitment;



/**
 * " We use this to track local commitment transactions and put off signing them until we are ready"
 * " to broadcast. Eventually this will require a signer which is possibly external, but for now we"
 * " just pass in the SecretKeys required."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnLocalCommitmentTransaction *inner;
    bool _underlying_ref;
} LDKLocalCommitmentTransaction;



/**
 * " Features used within a `node_announcement` message."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnNodeFeatures *inner;
    bool _underlying_ref;
} LDKNodeFeatures;



/**
 * " Features used within a `channel_announcement` message."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelFeatures *inner;
    bool _underlying_ref;
} LDKChannelFeatures;



/**
 * " A hop in a route"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnRouteHop *inner;
    bool _underlying_ref;
} LDKRouteHop;

typedef struct {
    LDKRouteHop *data;
    uintptr_t datalen;
} LDKCVecTempl_RouteHop;

typedef struct {
    LDKCVecTempl_RouteHop *data;
    uintptr_t datalen;
} LDKCVecTempl_CVecTempl_RouteHop;

typedef LDKCVecTempl_CVecTempl_RouteHop LDKCVec_CVec_RouteHopZZ;



/**
 * " A channel descriptor which provides a last-hop route to get_route"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnRouteHint *inner;
    bool _underlying_ref;
} LDKRouteHint;



/**
 * " Fees for routing via a given channel or a node"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnRoutingFees *inner;
    bool _underlying_ref;
} LDKRoutingFees;



/**
 * " Receives and validates network updates from peers,"
 * " stores authentic and relevant data as a network graph."
 * " This network graph is then used for routing payments."
 * " Provides interface to help with initial routing sync by"
 * " serving historical announcements."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnNetGraphMsgHandler *inner;
    bool _underlying_ref;
} LDKNetGraphMsgHandler;



/**
 * " Details about one direction of a channel. Received"
 * " within a channel update."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnDirectionalChannelInfo *inner;
    bool _underlying_ref;
} LDKDirectionalChannelInfo;



/**
 * " Details about a channel (both directions)."
 * " Received within a channel announcement."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnChannelInfo *inner;
    bool _underlying_ref;
} LDKChannelInfo;



/**
 * " Information received in the latest node_announcement from this node."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnNodeAnnouncementInfo *inner;
    bool _underlying_ref;
} LDKNodeAnnouncementInfo;



/**
 * " Details about a node in the network, known from the network announcement."
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnNodeInfo *inner;
    bool _underlying_ref;
} LDKNodeInfo;

typedef struct {
    uint64_t *data;
    uintptr_t datalen;
} LDKCVecTempl_u64;

typedef LDKCVecTempl_u64 LDKCVec_u64Z;



/**
 * " Represents the network as nodes and channels between them"
 */
typedef struct {
    /**
     * Nearly everyhwere, inner must be non-null, however in places where
     *the Rust equivalent takes an Option, it may be set to null to indicate None.
     */
    const LDKlnNetworkGraph *inner;
    bool _underlying_ref;
} LDKNetworkGraph;

typedef LDKC2TupleTempl_CVec_u8Z__u64 LDKC2Tuple_Scriptu64Z;

typedef LDKCVecTempl_RouteHop LDKCVec_RouteHopZ;

extern const void (*C2Tuple_Scriptu64Z_free)(LDKC2Tuple_Scriptu64Z);

extern const void (*C2Tuple_SecretKey_u832Z_free)(LDKC2Tuple_SecretKey_u832Z);

extern const void (*C2Tuple_Txidu32Z_free)(LDKC2Tuple_Txidu32Z);

extern const LDKCResult_C2Tuple_Scriptu64ZChainErrorZ (*CResult_C2Tuple_Scriptu64ZChainErrorZ_err)(LDKChainError);

extern const void (*CResult_C2Tuple_Scriptu64ZChainErrorZ_free)(LDKCResult_C2Tuple_Scriptu64ZChainErrorZ);

extern const LDKCResult_C2Tuple_Scriptu64ZChainErrorZ (*CResult_C2Tuple_Scriptu64ZChainErrorZ_good)(LDKC2Tuple_Scriptu64Z);

extern const LDKCResult_CVec_u8ZPeerHandleErrorZ (*CResult_CVec_u8ZPeerHandleErrorZ_err)(LDKPeerHandleError);

extern const void (*CResult_CVec_u8ZPeerHandleErrorZ_free)(LDKCResult_CVec_u8ZPeerHandleErrorZ);

extern const LDKCResult_CVec_u8ZPeerHandleErrorZ (*CResult_CVec_u8ZPeerHandleErrorZ_good)(LDKCVec_u8Z);

extern const LDKCResult_NoneAPIErrorZ (*CResult_NoneAPIErrorZ_err)(LDKAPIError);

extern const void (*CResult_NoneAPIErrorZ_free)(LDKCResult_NoneAPIErrorZ);

extern const LDKCResult_NoneChannelMonitorUpdateErrZ (*CResult_NoneChannelMonitorUpdateErrZ_err)(LDKChannelMonitorUpdateErr);

extern const void (*CResult_NoneChannelMonitorUpdateErrZ_free)(LDKCResult_NoneChannelMonitorUpdateErrZ);

extern const LDKCResult_NonePaymentSendFailureZ (*CResult_NonePaymentSendFailureZ_err)(LDKPaymentSendFailure);

extern const void (*CResult_NonePaymentSendFailureZ_free)(LDKCResult_NonePaymentSendFailureZ);

extern const LDKCResult_NonePeerHandleErrorZ (*CResult_NonePeerHandleErrorZ_err)(LDKPeerHandleError);

extern const void (*CResult_NonePeerHandleErrorZ_free)(LDKCResult_NonePeerHandleErrorZ);

extern const void (*CResult_SignatureNoneZ_free)(LDKCResult_SignatureNoneZ);

extern const LDKCResult_SignatureNoneZ (*CResult_SignatureNoneZ_good)(LDKSignature);

extern const LDKCResult_boolLightningErrorZ (*CResult_boolLightningErrorZ_err)(LDKLightningError);

extern const void (*CResult_boolLightningErrorZ_free)(LDKCResult_boolLightningErrorZ);

extern const LDKCResult_boolLightningErrorZ (*CResult_boolLightningErrorZ_good)(bool);

extern const LDKCResult_boolPeerHandleErrorZ (*CResult_boolPeerHandleErrorZ_err)(LDKPeerHandleError);

extern const void (*CResult_boolPeerHandleErrorZ_free)(LDKCResult_boolPeerHandleErrorZ);

extern const LDKCResult_boolPeerHandleErrorZ (*CResult_boolPeerHandleErrorZ_good)(bool);

extern const void (*CVec_CVec_RouteHopZZ_free)(LDKCVec_CVec_RouteHopZZ);

extern const void (*CVec_ChannelDetailsZ_free)(LDKCVec_ChannelDetailsZ);

extern const void (*CVec_EventZ_free)(LDKCVec_EventZ);

extern const void (*CVec_HTLCUpdateZ_free)(LDKCVec_HTLCUpdateZ);

extern const void (*CVec_MessageSendEventZ_free)(LDKCVec_MessageSendEventZ);

extern const void (*CVec_NetAddressZ_free)(LDKCVec_NetAddressZ);

extern const void (*CVec_PublicKeyZ_free)(LDKCVec_PublicKeyZ);

extern const void (*CVec_RouteHopZ_free)(LDKCVec_RouteHopZ);

extern const void (*CVec_UpdateAddHTLCZ_free)(LDKCVec_UpdateAddHTLCZ);

extern const void (*CVec_UpdateFailHTLCZ_free)(LDKCVec_UpdateFailHTLCZ);

extern const void (*CVec_UpdateFailMalformedHTLCZ_free)(LDKCVec_UpdateFailMalformedHTLCZ);

extern const void (*CVec_UpdateFulfillHTLCZ_free)(LDKCVec_UpdateFulfillHTLCZ);

extern const void (*CVec_u64Z_free)(LDKCVec_u64Z);

extern const void (*CVec_u8Z_free)(LDKCVec_u8Z);

LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err(void);

LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_good(void);

LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_good(void);

LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_good(void);

LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_good(void);

void Event_free(LDKEvent this_ptr);

void MessageSendEvent_free(LDKMessageSendEvent this_ptr);

void APIError_free(LDKAPIError this_ptr);

/**
 * " Returns the most verbose logging level."
 */
LDKLevel Level_max(void);

void UserConfig_free(LDKUserConfig this_ptr);

LDKUserConfig UserConfig_default(void);

void ChannelHandshakeConfig_free(LDKChannelHandshakeConfig this_ptr);

/**
 * " Confirmations we will wait for before considering the channel locked in."
 * " Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the"
 * " equivalent limit applied to outbound channels)."
 * ""
 * " Default value: 6."
 */
uint32_t ChannelHandshakeConfig_get_minimum_depth(const LDKChannelHandshakeConfig *this_ptr);

/**
 * " Confirmations we will wait for before considering the channel locked in."
 * " Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the"
 * " equivalent limit applied to outbound channels)."
 * ""
 * " Default value: 6."
 */
void ChannelHandshakeConfig_set_minimum_depth(LDKChannelHandshakeConfig *this_ptr, uint32_t val);

/**
 * " Set to the amount of time we require our counterparty to wait to claim their money."
 * ""
 * " It's one of the main parameter of our security model. We (or one of our watchtowers) MUST"
 * " be online to check for peer having broadcast a revoked transaction to steal our funds"
 * " at least once every our_to_self_delay blocks."
 * ""
 * " Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in"
 * " case of an honest unilateral channel close, which implicitly decrease the economic value of"
 * " our channel."
 * ""
 * " Default value: BREAKDOWN_TIMEOUT (currently 144), we enforce it as a minimum at channel"
 * " opening so you can tweak config to ask for more security, not less."
 */
uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const LDKChannelHandshakeConfig *this_ptr);

/**
 * " Set to the amount of time we require our counterparty to wait to claim their money."
 * ""
 * " It's one of the main parameter of our security model. We (or one of our watchtowers) MUST"
 * " be online to check for peer having broadcast a revoked transaction to steal our funds"
 * " at least once every our_to_self_delay blocks."
 * ""
 * " Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in"
 * " case of an honest unilateral channel close, which implicitly decrease the economic value of"
 * " our channel."
 * ""
 * " Default value: BREAKDOWN_TIMEOUT (currently 144), we enforce it as a minimum at channel"
 * " opening so you can tweak config to ask for more security, not less."
 */
void ChannelHandshakeConfig_set_our_to_self_delay(LDKChannelHandshakeConfig *this_ptr, uint16_t val);

/**
 * " Set to the smallest value HTLC we will accept to process."
 * ""
 * " This value is sent to our counterparty on channel-open and we close the channel any time"
 * " our counterparty misbehaves by sending us an HTLC with a value smaller than this."
 * ""
 * " Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required"
 * " by the protocol."
 */
uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const LDKChannelHandshakeConfig *this_ptr);

/**
 * " Set to the smallest value HTLC we will accept to process."
 * ""
 * " This value is sent to our counterparty on channel-open and we close the channel any time"
 * " our counterparty misbehaves by sending us an HTLC with a value smaller than this."
 * ""
 * " Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required"
 * " by the protocol."
 */
void ChannelHandshakeConfig_set_our_htlc_minimum_msat(LDKChannelHandshakeConfig *this_ptr, uint64_t val);

LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg);

LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);

void ChannelHandshakeLimits_free(LDKChannelHandshakeLimits this_ptr);

/**
 * " Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so"
 * " only applies to inbound channels."
 * ""
 * " Default value: 0."
 */
uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so"
 * " only applies to inbound channels."
 * ""
 * " Default value: 0."
 */
void ChannelHandshakeLimits_set_min_funding_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows"
 * " you to limit the maximum minimum-size they can require."
 * ""
 * " Default value: u64::max_value."
 */
uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows"
 * " you to limit the maximum minimum-size they can require."
 * ""
 * " Default value: u64::max_value."
 */
void ChannelHandshakeLimits_set_max_htlc_minimum_msat(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " The remote node sets a limit on the maximum value of pending HTLCs to them at any given"
 * " time to limit their funds exposure to HTLCs. This allows you to set a minimum such value."
 * ""
 * " Default value: 0."
 */
uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " The remote node sets a limit on the maximum value of pending HTLCs to them at any given"
 * " time to limit their funds exposure to HTLCs. This allows you to set a minimum such value."
 * ""
 * " Default value: 0."
 */
void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " The remote node will require we keep a certain amount in direct payment to ourselves at all"
 * " time, ensuring that we are able to be punished if we broadcast an old state. This allows to"
 * " you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs)."
 * ""
 * " Default value: u64::max_value."
 */
uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " The remote node will require we keep a certain amount in direct payment to ourselves at all"
 * " time, ensuring that we are able to be punished if we broadcast an old state. This allows to"
 * " you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs)."
 * ""
 * " Default value: u64::max_value."
 */
void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " The remote node sets a limit on the maximum number of pending HTLCs to them at any given"
 * " time. This allows you to set a minimum such value."
 * ""
 * " Default value: 0."
 */
uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " The remote node sets a limit on the maximum number of pending HTLCs to them at any given"
 * " time. This allows you to set a minimum such value."
 * ""
 * " Default value: 0."
 */
void ChannelHandshakeLimits_set_min_max_accepted_htlcs(LDKChannelHandshakeLimits *this_ptr, uint16_t val);

/**
 * " Outputs below a certain value will not be added to on-chain transactions. The dust value is"
 * " required to always be higher than this value so this only applies to HTLC outputs (and"
 * " potentially to-self outputs before any payments have been made)."
 * " Thus, HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain."
 * " This setting allows you to set a minimum dust limit for their commitment transactions,"
 * " reflecting the reality that tiny outputs are not considered standard transactions and will"
 * " not propagate through the Bitcoin network."
 * ""
 * " Default value: 546, the current dust limit on the Bitcoin network."
 */
uint64_t ChannelHandshakeLimits_get_min_dust_limit_satoshis(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " Outputs below a certain value will not be added to on-chain transactions. The dust value is"
 * " required to always be higher than this value so this only applies to HTLC outputs (and"
 * " potentially to-self outputs before any payments have been made)."
 * " Thus, HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain."
 * " This setting allows you to set a minimum dust limit for their commitment transactions,"
 * " reflecting the reality that tiny outputs are not considered standard transactions and will"
 * " not propagate through the Bitcoin network."
 * ""
 * " Default value: 546, the current dust limit on the Bitcoin network."
 */
void ChannelHandshakeLimits_set_min_dust_limit_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " Maximum allowed threshold above which outputs will not be generated in their commitment"
 * " transactions."
 * " HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain."
 * ""
 * " Default value: u64::max_value."
 */
uint64_t ChannelHandshakeLimits_get_max_dust_limit_satoshis(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " Maximum allowed threshold above which outputs will not be generated in their commitment"
 * " transactions."
 * " HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain."
 * ""
 * " Default value: u64::max_value."
 */
void ChannelHandshakeLimits_set_max_dust_limit_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " Before a channel is usable the funding transaction will need to be confirmed by at least a"
 * " certain number of blocks, specified by the node which is not the funder (as the funder can"
 * " assume they aren't going to double-spend themselves)."
 * " This config allows you to set a limit on the maximum amount of time to wait."
 * ""
 * " Default value: 144, or roughly one day and only applies to outbound channels."
 */
uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " Before a channel is usable the funding transaction will need to be confirmed by at least a"
 * " certain number of blocks, specified by the node which is not the funder (as the funder can"
 * " assume they aren't going to double-spend themselves)."
 * " This config allows you to set a limit on the maximum amount of time to wait."
 * ""
 * " Default value: 144, or roughly one day and only applies to outbound channels."
 */
void ChannelHandshakeLimits_set_max_minimum_depth(LDKChannelHandshakeLimits *this_ptr, uint32_t val);

/**
 * " Set to force the incoming channel to match our announced channel preference in"
 * " ChannelConfig."
 * ""
 * " Default value: true, to make the default that no announced channels are possible (which is"
 * " appropriate for any nodes which are not online very reliably)."
 */
bool ChannelHandshakeLimits_get_force_announced_channel_preference(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " Set to force the incoming channel to match our announced channel preference in"
 * " ChannelConfig."
 * ""
 * " Default value: true, to make the default that no announced channels are possible (which is"
 * " appropriate for any nodes which are not online very reliably)."
 */
void ChannelHandshakeLimits_set_force_announced_channel_preference(LDKChannelHandshakeLimits *this_ptr, bool val);

/**
 * " Set to the amount of time we're willing to wait to claim money back to us."
 * ""
 * " Not checking this value would be a security issue, as our peer would be able to set it to"
 * " max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time."
 * ""
 * " Default value: MAX_LOCAL_BREAKDOWN_TIMEOUT (1008), which we also enforce as a maximum value"
 * " so you can tweak config to reduce the loss of having useless locked funds (if your peer accepts)"
 */
uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const LDKChannelHandshakeLimits *this_ptr);

/**
 * " Set to the amount of time we're willing to wait to claim money back to us."
 * ""
 * " Not checking this value would be a security issue, as our peer would be able to set it to"
 * " max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time."
 * ""
 * " Default value: MAX_LOCAL_BREAKDOWN_TIMEOUT (1008), which we also enforce as a maximum value"
 * " so you can tweak config to reduce the loss of having useless locked funds (if your peer accepts)"
 */
void ChannelHandshakeLimits_set_their_to_self_delay(LDKChannelHandshakeLimits *this_ptr, uint16_t val);

LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint64_t min_dust_limit_satoshis_arg, uint64_t max_dust_limit_satoshis_arg, uint32_t max_minimum_depth_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);

LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);

void ChannelConfig_free(LDKChannelConfig this_ptr);

/**
 * " Amount (in millionths of a satoshi) the channel will charge per transferred satoshi."
 * " This may be allowed to change at runtime in a later update, however doing so must result in"
 * " update messages sent to notify all nodes of our updated relay fee."
 * ""
 * " Default value: 0."
 */
uint32_t ChannelConfig_get_fee_proportional_millionths(const LDKChannelConfig *this_ptr);

/**
 * " Amount (in millionths of a satoshi) the channel will charge per transferred satoshi."
 * " This may be allowed to change at runtime in a later update, however doing so must result in"
 * " update messages sent to notify all nodes of our updated relay fee."
 * ""
 * " Default value: 0."
 */
void ChannelConfig_set_fee_proportional_millionths(LDKChannelConfig *this_ptr, uint32_t val);

/**
 * " Set to announce the channel publicly and notify all nodes that they can route via this"
 * " channel."
 * ""
 * " This should only be set to true for nodes which expect to be online reliably."
 * ""
 * " As the node which funds a channel picks this value this will only apply for new outbound"
 * " channels unless ChannelHandshakeLimits::force_announced_channel_preferences is set."
 * ""
 * " This cannot be changed after the initial channel handshake."
 * ""
 * " Default value: false."
 */
bool ChannelConfig_get_announced_channel(const LDKChannelConfig *this_ptr);

/**
 * " Set to announce the channel publicly and notify all nodes that they can route via this"
 * " channel."
 * ""
 * " This should only be set to true for nodes which expect to be online reliably."
 * ""
 * " As the node which funds a channel picks this value this will only apply for new outbound"
 * " channels unless ChannelHandshakeLimits::force_announced_channel_preferences is set."
 * ""
 * " This cannot be changed after the initial channel handshake."
 * ""
 * " Default value: false."
 */
void ChannelConfig_set_announced_channel(LDKChannelConfig *this_ptr, bool val);

/**
 * " When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty"
 * " supports it, they will then enforce the mutual-close output to us matches what we provided"
 * " at intialization, preventing us from closing to an alternate pubkey."
 * ""
 * " This is set to true by default to provide a slight increase in security, though ultimately"
 * " any attacker who is able to take control of a channel can just as easily send the funds via"
 * " lightning payments, so we never require that our counterparties support this option."
 * ""
 * " This cannot be changed after a channel has been initialized."
 * ""
 * " Default value: true."
 */
bool ChannelConfig_get_commit_upfront_shutdown_pubkey(const LDKChannelConfig *this_ptr);

/**
 * " When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty"
 * " supports it, they will then enforce the mutual-close output to us matches what we provided"
 * " at intialization, preventing us from closing to an alternate pubkey."
 * ""
 * " This is set to true by default to provide a slight increase in security, though ultimately"
 * " any attacker who is able to take control of a channel can just as easily send the funds via"
 * " lightning payments, so we never require that our counterparties support this option."
 * ""
 * " This cannot be changed after a channel has been initialized."
 * ""
 * " Default value: true."
 */
void ChannelConfig_set_commit_upfront_shutdown_pubkey(LDKChannelConfig *this_ptr, bool val);

LDKChannelConfig ChannelConfig_new(uint32_t fee_proportional_millionths_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg);

LDKChannelConfig ChannelConfig_default(void);

void ChainWatchedUtil_free(LDKChainWatchedUtil this_ptr);

/**
 * " Constructs an empty (watches nothing) ChainWatchedUtil"
 */
LDKChainWatchedUtil ChainWatchedUtil_new(void);

/**
 * " Registers a tx for monitoring, returning true if it was a new tx and false if we'd already"
 * " been watching for it."
 */
bool ChainWatchedUtil_register_tx(LDKChainWatchedUtil *this_arg, const uint8_t (*txid)[32], LDKu8slice script_pub_key);

/**
 * " Registers an outpoint for monitoring, returning true if it was a new outpoint and false if"
 * " we'd already been watching for it"
 */
bool ChainWatchedUtil_register_outpoint(LDKChainWatchedUtil *this_arg, LDKC2Tuple_Txidu32Z outpoint, LDKu8slice _script_pub_key);

/**
 * " Sets us to match all transactions, returning true if this is a new setting and false if"
 * " we'd already been set to match everything."
 */
bool ChainWatchedUtil_watch_all(LDKChainWatchedUtil *this_arg);

/**
 * " Checks if a given transaction matches the current filter."
 */
bool ChainWatchedUtil_does_match_tx(const LDKChainWatchedUtil *this_arg, LDKTransaction tx);

void BlockNotifier_free(LDKBlockNotifier this_ptr);

/**
 * " Constructs a new BlockNotifier without any listeners."
 */
LDKBlockNotifier BlockNotifier_new(LDKChainWatchInterface chain_monitor);

/**
 * " Register the given listener to receive events."
 */
void BlockNotifier_register_listener(const LDKBlockNotifier *this_arg, LDKChainListener listener);

/**
 * " Notify listeners that a block was connected given a full, unfiltered block."
 * ""
 * " Handles re-scanning the block and calling block_connected again if listeners register new"
 * " watch data during the callbacks for you (see ChainListener::block_connected for more info)."
 */
void BlockNotifier_block_connected(const LDKBlockNotifier *this_arg, LDKu8slice block, uint32_t height);

/**
 * " Notify listeners that a block was disconnected."
 */
void BlockNotifier_block_disconnected(const LDKBlockNotifier *this_arg, const uint8_t (*header)[80], uint32_t disconnected_height);

void ChainWatchInterfaceUtil_free(LDKChainWatchInterfaceUtil this_ptr);

LDKChainWatchInterface ChainWatchInterfaceUtil_as_ChainWatchInterface(const LDKChainWatchInterfaceUtil *this_arg);

/**
 * " Creates a new ChainWatchInterfaceUtil for the given network"
 */
LDKChainWatchInterfaceUtil ChainWatchInterfaceUtil_new(LDKNetwork network);

/**
 * " Checks if a given transaction matches the current filter."
 */
bool ChainWatchInterfaceUtil_does_match_tx(const LDKChainWatchInterfaceUtil *this_arg, LDKTransaction tx);

void OutPoint_free(LDKOutPoint this_ptr);

/**
 * " The referenced transaction's txid."
 */
const uint8_t (*OutPoint_get_txid(const LDKOutPoint *this_ptr))[32];

/**
 * " The referenced transaction's txid."
 */
void OutPoint_set_txid(LDKOutPoint *this_ptr, LDKThirtyTwoBytes val);

/**
 * " The index of the referenced output in its transaction's vout."
 */
uint16_t OutPoint_get_index(const LDKOutPoint *this_ptr);

/**
 * " The index of the referenced output in its transaction's vout."
 */
void OutPoint_set_index(LDKOutPoint *this_ptr, uint16_t val);

LDKOutPoint OutPoint_new(LDKThirtyTwoBytes txid_arg, uint16_t index_arg);

/**
 * " Convert an `OutPoint` to a lightning channel id."
 */
LDKThirtyTwoBytes OutPoint_to_channel_id(const LDKOutPoint *this_arg);

void SpendableOutputDescriptor_free(LDKSpendableOutputDescriptor this_ptr);

void InMemoryChannelKeys_free(LDKInMemoryChannelKeys this_ptr);

/**
 * " Create a new InMemoryChannelKeys"
 */
LDKInMemoryChannelKeys InMemoryChannelKeys_new(LDKSecretKey funding_key, LDKSecretKey revocation_base_key, LDKSecretKey payment_key, LDKSecretKey delayed_payment_base_key, LDKSecretKey htlc_base_key, LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis);

LDKChannelKeys InMemoryChannelKeys_as_ChannelKeys(const LDKInMemoryChannelKeys *this_arg);

void KeysManager_free(LDKKeysManager this_ptr);

/**
 * " Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your"
 * " RNG is busted) this may panic (but more importantly, you will possibly lose funds)."
 * " starting_time isn't strictly required to actually be a time, but it must absolutely,"
 * " without a doubt, be unique to this instance. ie if you start multiple times with the same"
 * " seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to"
 * " simply use the current time (with very high precision)."
 * ""
 * " The seed MUST be backed up safely prior to use so that the keys can be re-created, however,"
 * " obviously, starting_time should be unique every time you reload the library - it is only"
 * " used to generate new ephemeral key data (which will be stored by the individual channel if"
 * " necessary)."
 * ""
 * " Note that the seed is required to recover certain on-chain funds independent of"
 * " ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any"
 * " channel, and some on-chain during-closing funds."
 * ""
 * " Note that until the 0.1 release there is no guarantee of backward compatibility between"
 * " versions. Once the library is more fully supported, the docs will be updated to include a"
 * " detailed description of the guarantee."
 */
LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], LDKNetwork network, uint64_t starting_time_secs, uint32_t starting_time_nanos);

LDKKeysInterface KeysManager_as_KeysInterface(const LDKKeysManager *this_arg);

void ChannelManager_free(LDKChannelManager this_ptr);

void ChannelDetails_free(LDKChannelDetails this_ptr);

/**
 * " The channel's ID (prior to funding transaction generation, this is a random 32 bytes,"
 * " thereafter this is the txid of the funding transaction xor the funding transaction output)."
 * " Note that this means this value is *not* persistent - it can change once during the"
 * " lifetime of the channel."
 */
const uint8_t (*ChannelDetails_get_channel_id(const LDKChannelDetails *this_ptr))[32];

/**
 * " The channel's ID (prior to funding transaction generation, this is a random 32 bytes,"
 * " thereafter this is the txid of the funding transaction xor the funding transaction output)."
 * " Note that this means this value is *not* persistent - it can change once during the"
 * " lifetime of the channel."
 */
void ChannelDetails_set_channel_id(LDKChannelDetails *this_ptr, LDKThirtyTwoBytes val);

/**
 * " The node_id of our counterparty"
 */
LDKPublicKey ChannelDetails_get_remote_network_id(const LDKChannelDetails *this_ptr);

/**
 * " The node_id of our counterparty"
 */
void ChannelDetails_set_remote_network_id(LDKChannelDetails *this_ptr, LDKPublicKey val);

/**
 * " The Features the channel counterparty provided upon last connection."
 * " Useful for routing as it is the most up-to-date copy of the counterparty's features and"
 * " many routing-relevant features are present in the init context."
 */
const LDKInitFeatures *ChannelDetails_get_counterparty_features(const LDKChannelDetails *this_ptr);

/**
 * " The Features the channel counterparty provided upon last connection."
 * " Useful for routing as it is the most up-to-date copy of the counterparty's features and"
 * " many routing-relevant features are present in the init context."
 */
void ChannelDetails_set_counterparty_features(LDKChannelDetails *this_ptr, LDKInitFeatures val);

/**
 * " The value, in satoshis, of this channel as appears in the funding output"
 */
uint64_t ChannelDetails_get_channel_value_satoshis(const LDKChannelDetails *this_ptr);

/**
 * " The value, in satoshis, of this channel as appears in the funding output"
 */
void ChannelDetails_set_channel_value_satoshis(LDKChannelDetails *this_ptr, uint64_t val);

/**
 * " The user_id passed in to create_channel, or 0 if the channel was inbound."
 */
uint64_t ChannelDetails_get_user_id(const LDKChannelDetails *this_ptr);

/**
 * " The user_id passed in to create_channel, or 0 if the channel was inbound."
 */
void ChannelDetails_set_user_id(LDKChannelDetails *this_ptr, uint64_t val);

/**
 * " The available outbound capacity for sending HTLCs to the remote peer. This does not include"
 * " any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not"
 * " available for inclusion in new outbound HTLCs). This further does not include any pending"
 * " outgoing HTLCs which are awaiting some other resolution to be sent."
 */
uint64_t ChannelDetails_get_outbound_capacity_msat(const LDKChannelDetails *this_ptr);

/**
 * " The available outbound capacity for sending HTLCs to the remote peer. This does not include"
 * " any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not"
 * " available for inclusion in new outbound HTLCs). This further does not include any pending"
 * " outgoing HTLCs which are awaiting some other resolution to be sent."
 */
void ChannelDetails_set_outbound_capacity_msat(LDKChannelDetails *this_ptr, uint64_t val);

/**
 * " The available inbound capacity for the remote peer to send HTLCs to us. This does not"
 * " include any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not"
 * " available for inclusion in new inbound HTLCs)."
 * " Note that there are some corner cases not fully handled here, so the actual available"
 * " inbound capacity may be slightly higher than this."
 */
uint64_t ChannelDetails_get_inbound_capacity_msat(const LDKChannelDetails *this_ptr);

/**
 * " The available inbound capacity for the remote peer to send HTLCs to us. This does not"
 * " include any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not"
 * " available for inclusion in new inbound HTLCs)."
 * " Note that there are some corner cases not fully handled here, so the actual available"
 * " inbound capacity may be slightly higher than this."
 */
void ChannelDetails_set_inbound_capacity_msat(LDKChannelDetails *this_ptr, uint64_t val);

/**
 * " True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)"
 * " the peer is connected, and (c) no monitor update failure is pending resolution."
 */
bool ChannelDetails_get_is_live(const LDKChannelDetails *this_ptr);

/**
 * " True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)"
 * " the peer is connected, and (c) no monitor update failure is pending resolution."
 */
void ChannelDetails_set_is_live(LDKChannelDetails *this_ptr, bool val);

void PaymentSendFailure_free(LDKPaymentSendFailure this_ptr);

/**
 * " Constructs a new ChannelManager to hold several channels and route between them."
 * ""
 * " This is the main \"logic hub\" for all channel-related actions, and implements"
 * " ChannelMessageHandler."
 * ""
 * " Non-proportional fees are fixed according to our risk using the provided fee estimator."
 * ""
 * " panics if channel_value_satoshis is >= `MAX_FUNDING_SATOSHIS`!"
 * ""
 * " Users must provide the current blockchain height from which to track onchain channel"
 * " funding outpoints and send payments with reliable timelocks."
 * ""
 * " Users need to notify the new ChannelManager when a new block is connected or"
 * " disconnected using its `block_connected` and `block_disconnected` methods."
 * " However, rather than calling these methods directly, the user should register"
 * " the ChannelManager as a listener to the BlockNotifier and call the BlockNotifier's"
 * " `block_(dis)connected` methods, which will notify all registered listeners in one"
 * " go."
 */
LDKChannelManager ChannelManager_new(LDKNetwork network, LDKFeeEstimator fee_est, LDKManyChannelMonitor monitor, LDKBroadcasterInterface tx_broadcaster, LDKLogger logger, LDKKeysInterface keys_manager, LDKUserConfig config, uintptr_t current_blockchain_height);

/**
 * " Creates a new outbound channel to the given remote node and with the given value."
 * ""
 * " user_id will be provided back as user_channel_id in FundingGenerationReady and"
 * " FundingBroadcastSafe events to allow tracking of which events correspond with which"
 * " create_channel call. Note that user_channel_id defaults to 0 for inbound channels, so you"
 * " may wish to avoid using 0 for user_id here."
 * ""
 * " If successful, will generate a SendOpenChannel message event, so you should probably poll"
 * " PeerManager::process_events afterwards."
 * ""
 * " Raises APIError::APIMisuseError when channel_value_satoshis > 2**24 or push_msat is"
 * " greater than channel_value_satoshis * 1k or channel_value_satoshis is < 1000."
 */
LDKCResult_NoneAPIErrorZ ChannelManager_create_channel(const LDKChannelManager *this_arg, LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, uint64_t user_id, LDKUserConfig override_config);

/**
 * " Gets the list of open channels, in random order. See ChannelDetail field documentation for"
 * " more information."
 */
LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const LDKChannelManager *this_arg);

/**
 * " Gets the list of usable channels, in random order. Useful as an argument to"
 * " get_route to ensure non-announced channels are used."
 * ""
 * " These are guaranteed to have their is_live value set to true, see the documentation for"
 * " ChannelDetails::is_live for more info on exactly what the criteria are."
 */
LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const LDKChannelManager *this_arg);

/**
 * " Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs"
 * " will be accepted on the given channel, and after additional timeout/the closing of all"
 * " pending HTLCs, the channel will be closed on chain."
 * ""
 * " May generate a SendShutdown message event on success, which should be relayed."
 */
LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const LDKChannelManager *this_arg, const uint8_t (*channel_id)[32]);

/**
 * " Force closes a channel, immediately broadcasting the latest local commitment transaction to"
 * " the chain and rejecting new HTLCs on the given channel."
 */
void ChannelManager_force_close_channel(const LDKChannelManager *this_arg, const uint8_t (*channel_id)[32]);

/**
 * " Force close all channels, immediately broadcasting the latest local commitment transaction"
 * " for each to the chain and rejecting new HTLCs on each."
 */
void ChannelManager_force_close_all_channels(const LDKChannelManager *this_arg);

/**
 * " Sends a payment along a given route."
 * ""
 * " Value parameters are provided via the last hop in route, see documentation for RouteHop"
 * " fields for more info."
 * ""
 * " Note that if the payment_hash already exists elsewhere (eg you're sending a duplicative"
 * " payment), we don't do anything to stop you! We always try to ensure that if the provided"
 * " next hop knows the preimage to payment_hash they can claim an additional amount as"
 * " specified in the last hop in the route! Thus, you should probably do your own"
 * " payment_preimage tracking (which you should already be doing as they represent \"proof of"
 * " payment\") and prevent double-sends yourself."
 * ""
 * " May generate SendHTLCs message(s) event on success, which should be relayed."
 * ""
 * " Each path may have a different return value, and PaymentSendValue may return a Vec with"
 * " each entry matching the corresponding-index entry in the route paths, see"
 * " PaymentSendFailure for more info."
 * ""
 * " In general, a path may raise:"
 * "  * APIError::RouteError when an invalid route or forwarding parameter (cltv_delta, fee,"
 * "    node public key) is specified."
 * "  * APIError::ChannelUnavailable if the next-hop channel is not available for updates"
 * "    (including due to previous monitor update failure or new permanent monitor update"
 * "    failure)."
 * "  * APIError::MonitorUpdateFailed if a new monitor update failure prevented sending the"
 * "    relevant updates."
 * ""
 * " Note that depending on the type of the PaymentSendFailure the HTLC may have been"
 * " irrevocably committed to on our end. In such a case, do NOT retry the payment with a"
 * " different route unless you intend to pay twice!"
 * ""
 * " payment_secret is unrelated to payment_hash (or PaymentPreimage) and exists to authenticate"
 * " the sender to the recipient and prevent payment-probing (deanonymization) attacks. For"
 * " newer nodes, it will be provided to you in the invoice. If you do not have one, the Route"
 * " must not contain multiple paths as multi-path payments require a recipient-provided"
 * " payment_secret."
 * " If a payment_secret *is* provided, we assume that the invoice had the payment_secret feature"
 * " bit set (either as required or as available). If multiple paths are present in the Route,"
 * " we assume the invoice had the basic_mpp feature set."
 */
LDKCResult_NonePaymentSendFailureZ ChannelManager_send_payment(const LDKChannelManager *this_arg, const LDKRoute *route, uint8_t payment_hash[32], const uint8_t (*payment_secret)[32]);

/**
 * " Call this upon creation of a funding transaction for the given channel."
 * ""
 * " Note that ALL inputs in the transaction pointed to by funding_txo MUST spend SegWit outputs"
 * " or your counterparty can steal your funds!"
 * ""
 * " Panics if a funding transaction has already been provided for this channel."
 * ""
 * " May panic if the funding_txo is duplicative with some other channel (note that this should"
 * " be trivially prevented by using unique funding transaction keys per-channel)."
 */
void ChannelManager_funding_transaction_generated(const LDKChannelManager *this_arg, const uint8_t (*temporary_channel_id)[32], LDKOutPoint funding_txo);

/**
 * " Generates a signed node_announcement from the given arguments and creates a"
 * " BroadcastNodeAnnouncement event. Note that such messages will be ignored unless peers have"
 * " seen a channel_announcement from us (ie unless we have public channels open)."
 * ""
 * " RGB is a node \"color\" and alias is a printable human-readable string to describe this node"
 * " to humans. They carry no in-protocol meaning."
 * ""
 * " addresses represent the set (possibly empty) of socket addresses on which this node accepts"
 * " incoming connections. These will be broadcast to the network, publicly tying these"
 * " addresses together. If you wish to preserve user privacy, addresses should likely contain"
 * " only Tor Onion addresses."
 * ""
 * " Panics if addresses is absurdly large (more than 500)."
 */
void ChannelManager_broadcast_node_announcement(const LDKChannelManager *this_arg, LDKThreeBytes rgb, LDKThirtyTwoBytes alias, LDKCVec_NetAddressZ addresses);

/**
 * " Processes HTLCs which are pending waiting on random forward delay."
 * ""
 * " Should only really ever be called in response to a PendingHTLCsForwardable event."
 * " Will likely generate further events."
 */
void ChannelManager_process_pending_htlc_forwards(const LDKChannelManager *this_arg);

/**
 * " If a peer is disconnected we mark any channels with that peer as 'disabled'."
 * " After some time, if channels are still disabled we need to broadcast a ChannelUpdate"
 * " to inform the network about the uselessness of these channels."
 * ""
 * " This method handles all the details, and must be called roughly once per minute."
 */
void ChannelManager_timer_chan_freshness_every_min(const LDKChannelManager *this_arg);

/**
 * " Indicates that the preimage for payment_hash is unknown or the received amount is incorrect"
 * " after a PaymentReceived event, failing the HTLC back to its origin and freeing resources"
 * " along the path (including in our own channel on which we received it)."
 * " Returns false if no payment was found to fail backwards, true if the process of failing the"
 * " HTLC backwards has been started."
 */
bool ChannelManager_fail_htlc_backwards(const LDKChannelManager *this_arg, const uint8_t (*payment_hash)[32], const uint8_t (*payment_secret)[32]);

/**
 * " Provides a payment preimage in response to a PaymentReceived event, returning true and"
 * " generating message events for the net layer to claim the payment, if possible. Thus, you"
 * " should probably kick the net layer to go send messages if this returns true!"
 * ""
 * " You must specify the expected amounts for this HTLC, and we will only claim HTLCs"
 * " available within a few percent of the expected amount. This is critical for several"
 * " reasons : a) it avoids providing senders with `proof-of-payment` (in the form of the"
 * " payment_preimage without having provided the full value and b) it avoids certain"
 * " privacy-breaking recipient-probing attacks which may reveal payment activity to"
 * " motivated attackers."
 * ""
 * " Note that the privacy concerns in (b) are not relevant in payments with a payment_secret"
 * " set. Thus, for such payments we will claim any payments which do not under-pay."
 * ""
 * " May panic if called except in response to a PaymentReceived event."
 */
bool ChannelManager_claim_funds(const LDKChannelManager *this_arg, uint8_t payment_preimage[32], const uint8_t (*payment_secret)[32], uint64_t expected_amount);

/**
 * " Gets the node_id held by this ChannelManager"
 */
LDKPublicKey ChannelManager_get_our_node_id(const LDKChannelManager *this_arg);

/**
 * " Restores a single, given channel to normal operation after a"
 * " ChannelMonitorUpdateErr::TemporaryFailure was returned from a channel monitor update"
 * " operation."
 * ""
 * " All ChannelMonitor updates up to and including highest_applied_update_id must have been"
 * " fully committed in every copy of the given channels' ChannelMonitors."
 * ""
 * " Note that there is no effect to calling with a highest_applied_update_id other than the"
 * " current latest ChannelMonitorUpdate and one call to this function after multiple"
 * " ChannelMonitorUpdateErr::TemporaryFailures is fine. The highest_applied_update_id field"
 * " exists largely only to prevent races between this and concurrent update_monitor calls."
 * ""
 * " Thus, the anticipated use is, at a high level:"
 * "  1) You register a ManyChannelMonitor with this ChannelManager,"
 * "  2) it stores each update to disk, and begins updating any remote (eg watchtower) copies of"
 * "     said ChannelMonitors as it can, returning ChannelMonitorUpdateErr::TemporaryFailures"
 * "     any time it cannot do so instantly,"
 * "  3) update(s) are applied to each remote copy of a ChannelMonitor,"
 * "  4) once all remote copies are updated, you call this function with the update_id that"
 * "     completed, and once it is the latest the Channel will be re-enabled."
 */
void ChannelManager_channel_monitor_updated(const LDKChannelManager *this_arg, const LDKOutPoint *funding_txo, uint64_t highest_applied_update_id);

LDKEventsProvider ChannelManager_as_EventsProvider(const LDKChannelManager *this_arg);

LDKChainListener ChannelManager_as_ChainListener(const LDKChannelManager *this_arg);

LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const LDKChannelManager *this_arg);

void ChannelMonitorUpdate_free(LDKChannelMonitorUpdate this_ptr);

/**
 * " The sequence number of this update. Updates *must* be replayed in-order according to this"
 * " sequence number (and updates may panic if they are not). The update_id values are strictly"
 * " increasing and increase by one for each new update."
 * ""
 * " This sequence number is also used to track up to which points updates which returned"
 * " ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given"
 * " ChannelMonitor when ChannelManager::channel_monitor_updated is called."
 */
uint64_t ChannelMonitorUpdate_get_update_id(const LDKChannelMonitorUpdate *this_ptr);

/**
 * " The sequence number of this update. Updates *must* be replayed in-order according to this"
 * " sequence number (and updates may panic if they are not). The update_id values are strictly"
 * " increasing and increase by one for each new update."
 * ""
 * " This sequence number is also used to track up to which points updates which returned"
 * " ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given"
 * " ChannelMonitor when ChannelManager::channel_monitor_updated is called."
 */
void ChannelMonitorUpdate_set_update_id(LDKChannelMonitorUpdate *this_ptr, uint64_t val);

void MonitorUpdateError_free(LDKMonitorUpdateError this_ptr);

void HTLCUpdate_free(LDKHTLCUpdate this_ptr);

void ChannelMonitor_free(LDKChannelMonitor this_ptr);

/**
 * " Gets the update_id from the latest ChannelMonitorUpdate which was applied to this"
 * " ChannelMonitor."
 */
uint64_t ChannelMonitor_get_latest_update_id(const LDKChannelMonitor *this_arg);

/**
 * " Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for."
 */
LDKOutPoint ChannelMonitor_get_funding_txo(const LDKChannelMonitor *this_arg);

/**
 * " Get the list of HTLCs who's status has been updated on chain. This should be called by"
 * " ChannelManager via ManyChannelMonitor::get_and_clear_pending_htlcs_updated()."
 */
LDKCVec_HTLCUpdateZ ChannelMonitor_get_and_clear_pending_htlcs_updated(LDKChannelMonitor *this_arg);

void DecodeError_free(LDKDecodeError this_ptr);

void Init_free(LDKInit this_ptr);

void ErrorMessage_free(LDKErrorMessage this_ptr);

void Ping_free(LDKPing this_ptr);

void Pong_free(LDKPong this_ptr);

void OpenChannel_free(LDKOpenChannel this_ptr);

void AcceptChannel_free(LDKAcceptChannel this_ptr);

void FundingCreated_free(LDKFundingCreated this_ptr);

void FundingSigned_free(LDKFundingSigned this_ptr);

void FundingLocked_free(LDKFundingLocked this_ptr);

const uint8_t (*FundingLocked_get_channel_id(const LDKFundingLocked *this_ptr))[32];

void FundingLocked_set_channel_id(LDKFundingLocked *this_ptr, LDKThirtyTwoBytes val);

LDKPublicKey FundingLocked_get_next_per_commitment_point(const LDKFundingLocked *this_ptr);

void FundingLocked_set_next_per_commitment_point(LDKFundingLocked *this_ptr, LDKPublicKey val);

LDKFundingLocked FundingLocked_new(LDKThirtyTwoBytes channel_id_arg, LDKPublicKey next_per_commitment_point_arg);

void Shutdown_free(LDKShutdown this_ptr);

void ClosingSigned_free(LDKClosingSigned this_ptr);

void UpdateAddHTLC_free(LDKUpdateAddHTLC this_ptr);

void UpdateFulfillHTLC_free(LDKUpdateFulfillHTLC this_ptr);

void UpdateFailHTLC_free(LDKUpdateFailHTLC this_ptr);

void UpdateFailMalformedHTLC_free(LDKUpdateFailMalformedHTLC this_ptr);

void CommitmentSigned_free(LDKCommitmentSigned this_ptr);

void RevokeAndACK_free(LDKRevokeAndACK this_ptr);

void UpdateFee_free(LDKUpdateFee this_ptr);

void ChannelReestablish_free(LDKChannelReestablish this_ptr);

void AnnouncementSignatures_free(LDKAnnouncementSignatures this_ptr);

void NetAddress_free(LDKNetAddress this_ptr);

void UnsignedNodeAnnouncement_free(LDKUnsignedNodeAnnouncement this_ptr);

/**
 * " The node_id this announcement originated from (don't rebroadcast the node_announcement back"
 * " to this node)."
 */
LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const LDKUnsignedNodeAnnouncement *this_ptr);

/**
 * " The node_id this announcement originated from (don't rebroadcast the node_announcement back"
 * " to this node)."
 */
void UnsignedNodeAnnouncement_set_node_id(LDKUnsignedNodeAnnouncement *this_ptr, LDKPublicKey val);

void NodeAnnouncement_free(LDKNodeAnnouncement this_ptr);

void UnsignedChannelAnnouncement_free(LDKUnsignedChannelAnnouncement this_ptr);

/**
 * " One of the two node_ids which are endpoints of this channel"
 */
LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const LDKUnsignedChannelAnnouncement *this_ptr);

/**
 * " One of the two node_ids which are endpoints of this channel"
 */
void UnsignedChannelAnnouncement_set_node_id_1(LDKUnsignedChannelAnnouncement *this_ptr, LDKPublicKey val);

/**
 * " The other of the two node_ids which are endpoints of this channel"
 */
LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const LDKUnsignedChannelAnnouncement *this_ptr);

/**
 * " The other of the two node_ids which are endpoints of this channel"
 */
void UnsignedChannelAnnouncement_set_node_id_2(LDKUnsignedChannelAnnouncement *this_ptr, LDKPublicKey val);

void ChannelAnnouncement_free(LDKChannelAnnouncement this_ptr);

void ChannelUpdate_free(LDKChannelUpdate this_ptr);

void LightningError_free(LDKLightningError this_ptr);

void CommitmentUpdate_free(LDKCommitmentUpdate this_ptr);

/**
 * " update_add_htlc messages which should be sent"
 */
void CommitmentUpdate_set_update_add_htlcs(LDKCommitmentUpdate *this_ptr, LDKCVec_UpdateAddHTLCZ val);

/**
 * " update_fulfill_htlc messages which should be sent"
 */
void CommitmentUpdate_set_update_fulfill_htlcs(LDKCommitmentUpdate *this_ptr, LDKCVec_UpdateFulfillHTLCZ val);

/**
 * " update_fail_htlc messages which should be sent"
 */
void CommitmentUpdate_set_update_fail_htlcs(LDKCommitmentUpdate *this_ptr, LDKCVec_UpdateFailHTLCZ val);

/**
 * " update_fail_malformed_htlc messages which should be sent"
 */
void CommitmentUpdate_set_update_fail_malformed_htlcs(LDKCommitmentUpdate *this_ptr, LDKCVec_UpdateFailMalformedHTLCZ val);

/**
 * " An update_fee message which should be sent"
 */
const LDKUpdateFee *CommitmentUpdate_get_update_fee(const LDKCommitmentUpdate *this_ptr);

/**
 * " An update_fee message which should be sent"
 */
void CommitmentUpdate_set_update_fee(LDKCommitmentUpdate *this_ptr, LDKUpdateFee val);

/**
 * " Finally, the commitment_signed message which should be sent"
 */
const LDKCommitmentSigned *CommitmentUpdate_get_commitment_signed(const LDKCommitmentUpdate *this_ptr);

/**
 * " Finally, the commitment_signed message which should be sent"
 */
void CommitmentUpdate_set_commitment_signed(LDKCommitmentUpdate *this_ptr, LDKCommitmentSigned val);

LDKCommitmentUpdate CommitmentUpdate_new(LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, LDKUpdateFee update_fee_arg, LDKCommitmentSigned commitment_signed_arg);

void HTLCFailChannelUpdate_free(LDKHTLCFailChannelUpdate this_ptr);

void MessageHandler_free(LDKMessageHandler this_ptr);

/**
 * " A message handler which handles messages specific to channels. Usually this is just a"
 * " ChannelManager object."
 */
const LDKChannelMessageHandler *MessageHandler_get_chan_handler(const LDKMessageHandler *this_ptr);

/**
 * " A message handler which handles messages specific to channels. Usually this is just a"
 * " ChannelManager object."
 */
void MessageHandler_set_chan_handler(LDKMessageHandler *this_ptr, LDKChannelMessageHandler val);

/**
 * " A message handler which handles messages updating our knowledge of the network channel"
 * " graph. Usually this is just a NetGraphMsgHandlerMonitor object."
 */
const LDKRoutingMessageHandler *MessageHandler_get_route_handler(const LDKMessageHandler *this_ptr);

/**
 * " A message handler which handles messages updating our knowledge of the network channel"
 * " graph. Usually this is just a NetGraphMsgHandlerMonitor object."
 */
void MessageHandler_set_route_handler(LDKMessageHandler *this_ptr, LDKRoutingMessageHandler val);

LDKMessageHandler MessageHandler_new(LDKChannelMessageHandler chan_handler_arg, LDKRoutingMessageHandler route_handler_arg);

void PeerHandleError_free(LDKPeerHandleError this_ptr);

/**
 * " Used to indicate that we probably can't make any future connections to this peer, implying"
 * " we should go ahead and force-close any channels we have with it."
 */
bool PeerHandleError_get_no_connection_possible(const LDKPeerHandleError *this_ptr);

/**
 * " Used to indicate that we probably can't make any future connections to this peer, implying"
 * " we should go ahead and force-close any channels we have with it."
 */
void PeerHandleError_set_no_connection_possible(LDKPeerHandleError *this_ptr, bool val);

LDKPeerHandleError PeerHandleError_new(bool no_connection_possible_arg);

void PeerManager_free(LDKPeerManager this_ptr);

/**
 * " Constructs a new PeerManager with the given message handlers and node_id secret key"
 * " ephemeral_random_data is used to derive per-connection ephemeral keys and must be"
 * " cryptographically secure random bytes."
 */
LDKPeerManager PeerManager_new(LDKMessageHandler message_handler, LDKSecretKey our_node_secret, const uint8_t (*ephemeral_random_data)[32], LDKLogger logger);

/**
 * " Get the list of node ids for peers which have completed the initial handshake."
 * ""
 * " For outbound connections, this will be the same as the their_node_id parameter passed in to"
 * " new_outbound_connection, however entries will only appear once the initial handshake has"
 * " completed and we are sure the remote peer has the private key for the given node_id."
 */
LDKCVec_PublicKeyZ PeerManager_get_peer_node_ids(const LDKPeerManager *this_arg);

/**
 * " Indicates a new outbound connection has been established to a node with the given node_id."
 * " Note that if an Err is returned here you MUST NOT call socket_disconnected for the new"
 * " descriptor but must disconnect the connection immediately."
 * ""
 * " Returns a small number of bytes to send to the remote node (currently always 50)."
 * ""
 * " Panics if descriptor is duplicative with some other descriptor which has not yet had a"
 * " socket_disconnected()."
 */
LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const LDKPeerManager *this_arg, LDKPublicKey their_node_id, LDKSocketDescriptor descriptor);

/**
 * " Indicates a new inbound connection has been established."
 * ""
 * " May refuse the connection by returning an Err, but will never write bytes to the remote end"
 * " (outbound connector always speaks first). Note that if an Err is returned here you MUST NOT"
 * " call socket_disconnected for the new descriptor but must disconnect the connection"
 * " immediately."
 * ""
 * " Panics if descriptor is duplicative with some other descriptor which has not yet had"
 * " socket_disconnected called."
 */
LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const LDKPeerManager *this_arg, LDKSocketDescriptor descriptor);

/**
 * " Indicates that there is room to write data to the given socket descriptor."
 * ""
 * " May return an Err to indicate that the connection should be closed."
 * ""
 * " Will most likely call send_data on the descriptor passed in (or the descriptor handed into"
 * " new_*\\_connection) before returning. Thus, be very careful with reentrancy issues! The"
 * " invariants around calling write_buffer_space_avail in case a write did not fully complete"
 * " must still hold - be ready to call write_buffer_space_avail again if a write call generated"
 * " here isn't sufficient! Panics if the descriptor was not previously registered in a"
 * " new_\\*_connection event."
 */
LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const LDKPeerManager *this_arg, LDKSocketDescriptor *descriptor);

/**
 * " Indicates that data was read from the given socket descriptor."
 * ""
 * " May return an Err to indicate that the connection should be closed."
 * ""
 * " Will *not* call back into send_data on any descriptors to avoid reentrancy complexity."
 * " Thus, however, you almost certainly want to call process_events() after any read_event to"
 * " generate send_data calls to handle responses."
 * ""
 * " If Ok(true) is returned, further read_events should not be triggered until a send_data call"
 * " on this file descriptor has resume_read set (preventing DoS issues in the send buffer)."
 * ""
 * " Panics if the descriptor was not previously registered in a new_*_connection event."
 */
LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const LDKPeerManager *this_arg, LDKSocketDescriptor *peer_descriptor, LDKu8slice data);

/**
 * " Checks for any events generated by our handlers and processes them. Includes sending most"
 * " response messages as well as messages generated by calls to handler functions directly (eg"
 * " functions like ChannelManager::process_pending_htlc_forward or send_payment)."
 */
void PeerManager_process_events(const LDKPeerManager *this_arg);

/**
 * " Indicates that the given socket descriptor's connection is now closed."
 * ""
 * " This must only be called if the socket has been disconnected by the peer or your own"
 * " decision to disconnect it and must NOT be called in any case where other parts of this"
 * " library (eg PeerHandleError, explicit disconnect_socket calls) instruct you to disconnect"
 * " the peer."
 * ""
 * " Panics if the descriptor was not previously registered in a successful new_*_connection event."
 */
void PeerManager_socket_disconnected(const LDKPeerManager *this_arg, const LDKSocketDescriptor *descriptor);

/**
 * " This function should be called roughly once every 30 seconds."
 * " It will send pings to each peer and disconnect those which did not respond to the last round of pings."
 * " Will most likely call send_data on all of the registered descriptors, thus, be very careful with reentrancy issues!"
 */
void PeerManager_timer_tick_occured(const LDKPeerManager *this_arg);

void TxCreationKeys_free(LDKTxCreationKeys this_ptr);

/**
 * " The per-commitment public key which was used to derive the other keys."
 */
LDKPublicKey TxCreationKeys_get_per_commitment_point(const LDKTxCreationKeys *this_ptr);

/**
 * " The per-commitment public key which was used to derive the other keys."
 */
void TxCreationKeys_set_per_commitment_point(LDKTxCreationKeys *this_ptr, LDKPublicKey val);

void ChannelPublicKeys_free(LDKChannelPublicKeys this_ptr);

/**
 * " The public key which is used to sign all commitment transactions, as it appears in the"
 * " on-chain channel lock-in 2-of-2 multisig output."
 */
LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const LDKChannelPublicKeys *this_ptr);

/**
 * " The public key which is used to sign all commitment transactions, as it appears in the"
 * " on-chain channel lock-in 2-of-2 multisig output."
 */
void ChannelPublicKeys_set_funding_pubkey(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

/**
 * " The base point which is used (with derive_public_revocation_key) to derive per-commitment"
 * " revocation keys. The per-commitment revocation private key is then revealed by the owner of"
 * " a commitment transaction so that their counterparty can claim all available funds if they"
 * " broadcast an old state."
 */
LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const LDKChannelPublicKeys *this_ptr);

/**
 * " The base point which is used (with derive_public_revocation_key) to derive per-commitment"
 * " revocation keys. The per-commitment revocation private key is then revealed by the owner of"
 * " a commitment transaction so that their counterparty can claim all available funds if they"
 * " broadcast an old state."
 */
void ChannelPublicKeys_set_revocation_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

/**
 * " The public key which receives our immediately spendable primary channel balance in"
 * " remote-broadcasted commitment transactions. This key is static across every commitment"
 * " transaction."
 */
LDKPublicKey ChannelPublicKeys_get_payment_point(const LDKChannelPublicKeys *this_ptr);

/**
 * " The public key which receives our immediately spendable primary channel balance in"
 * " remote-broadcasted commitment transactions. This key is static across every commitment"
 * " transaction."
 */
void ChannelPublicKeys_set_payment_point(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

/**
 * " The base point which is used (with derive_public_key) to derive a per-commitment payment"
 * " public key which receives non-HTLC-encumbered funds which are only available for spending"
 * " after some delay (or can be claimed via the revocation path)."
 */
LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const LDKChannelPublicKeys *this_ptr);

/**
 * " The base point which is used (with derive_public_key) to derive a per-commitment payment"
 * " public key which receives non-HTLC-encumbered funds which are only available for spending"
 * " after some delay (or can be claimed via the revocation path)."
 */
void ChannelPublicKeys_set_delayed_payment_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

/**
 * " The base point which is used (with derive_public_key) to derive a per-commitment public key"
 * " which is used to encumber HTLC-in-flight outputs."
 */
LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const LDKChannelPublicKeys *this_ptr);

/**
 * " The base point which is used (with derive_public_key) to derive a per-commitment public key"
 * " which is used to encumber HTLC-in-flight outputs."
 */
void ChannelPublicKeys_set_htlc_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

LDKChannelPublicKeys ChannelPublicKeys_new(LDKPublicKey funding_pubkey_arg, LDKPublicKey revocation_basepoint_arg, LDKPublicKey payment_point_arg, LDKPublicKey delayed_payment_basepoint_arg, LDKPublicKey htlc_basepoint_arg);

void HTLCOutputInCommitment_free(LDKHTLCOutputInCommitment this_ptr);

/**
 * " Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction)."
 * " Note that this is not the same as whether it is ountbound *from us*. To determine that you"
 * " need to compare this value to whether the commitment transaction in question is that of"
 * " the remote party or our own."
 */
bool HTLCOutputInCommitment_get_offered(const LDKHTLCOutputInCommitment *this_ptr);

/**
 * " Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction)."
 * " Note that this is not the same as whether it is ountbound *from us*. To determine that you"
 * " need to compare this value to whether the commitment transaction in question is that of"
 * " the remote party or our own."
 */
void HTLCOutputInCommitment_set_offered(LDKHTLCOutputInCommitment *this_ptr, bool val);

/**
 * " The value, in msat, of the HTLC. The value as it appears in the commitment transaction is"
 * " this divided by 1000."
 */
uint64_t HTLCOutputInCommitment_get_amount_msat(const LDKHTLCOutputInCommitment *this_ptr);

/**
 * " The value, in msat, of the HTLC. The value as it appears in the commitment transaction is"
 * " this divided by 1000."
 */
void HTLCOutputInCommitment_set_amount_msat(LDKHTLCOutputInCommitment *this_ptr, uint64_t val);

/**
 * " The CLTV lock-time at which this HTLC expires."
 */
uint32_t HTLCOutputInCommitment_get_cltv_expiry(const LDKHTLCOutputInCommitment *this_ptr);

/**
 * " The CLTV lock-time at which this HTLC expires."
 */
void HTLCOutputInCommitment_set_cltv_expiry(LDKHTLCOutputInCommitment *this_ptr, uint32_t val);

/**
 * " The hash of the preimage which unlocks this HTLC."
 */
const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const LDKHTLCOutputInCommitment *this_ptr))[32];

/**
 * " The hash of the preimage which unlocks this HTLC."
 */
void HTLCOutputInCommitment_set_payment_hash(LDKHTLCOutputInCommitment *this_ptr, uint8_t val[32]);

void LocalCommitmentTransaction_free(LDKLocalCommitmentTransaction this_ptr);

/**
 * " The commitment transaction itself, in unsigned form."
 */
LDKTransaction LocalCommitmentTransaction_get_unsigned_tx(const LDKLocalCommitmentTransaction *this_ptr);

/**
 * " The commitment transaction itself, in unsigned form."
 */
void LocalCommitmentTransaction_set_unsigned_tx(LDKLocalCommitmentTransaction *this_ptr, LDKTransaction val);

/**
 * " Our counterparty's signature for the transaction, above."
 */
LDKSignature LocalCommitmentTransaction_get_their_sig(const LDKLocalCommitmentTransaction *this_ptr);

/**
 * " Our counterparty's signature for the transaction, above."
 */
void LocalCommitmentTransaction_set_their_sig(LDKLocalCommitmentTransaction *this_ptr, LDKSignature val);

/**
 * " The key derivation parameters for this commitment transaction"
 */
const LDKTxCreationKeys *LocalCommitmentTransaction_get_local_keys(const LDKLocalCommitmentTransaction *this_ptr);

/**
 * " The key derivation parameters for this commitment transaction"
 */
void LocalCommitmentTransaction_set_local_keys(LDKLocalCommitmentTransaction *this_ptr, LDKTxCreationKeys val);

/**
 * " The feerate paid per 1000-weight-unit in this commitment transaction. This value is"
 * " controlled by the channel initiator."
 */
uint64_t LocalCommitmentTransaction_get_feerate_per_kw(const LDKLocalCommitmentTransaction *this_ptr);

/**
 * " The feerate paid per 1000-weight-unit in this commitment transaction. This value is"
 * " controlled by the channel initiator."
 */
void LocalCommitmentTransaction_set_feerate_per_kw(LDKLocalCommitmentTransaction *this_ptr, uint64_t val);

/**
 * " Gets our signature for the contained commitment transaction given our funding private key."
 * ""
 * " Funding key is your key included in the 2-2 funding_outpoint lock. Should be provided"
 * " by your ChannelKeys."
 * " Funding redeemscript is script locking funding_outpoint. This is the mutlsig script"
 * " between your own funding key and your counterparty's. Currently, this is provided in"
 * " ChannelKeys::sign_local_commitment() calls directly."
 * " Channel value is amount locked in funding_outpoint."
 */
LDKSignature LocalCommitmentTransaction_get_local_sig(const LDKLocalCommitmentTransaction *this_arg, const uint8_t (*funding_key)[32], LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

void InitFeatures_free(LDKInitFeatures this_ptr);

void NodeFeatures_free(LDKNodeFeatures this_ptr);

void ChannelFeatures_free(LDKChannelFeatures this_ptr);

void RouteHop_free(LDKRouteHop this_ptr);

/**
 * " The node_id of the node at this hop."
 */
LDKPublicKey RouteHop_get_pubkey(const LDKRouteHop *this_ptr);

/**
 * " The node_id of the node at this hop."
 */
void RouteHop_set_pubkey(LDKRouteHop *this_ptr, LDKPublicKey val);

/**
 * " The channel that should be used from the previous hop to reach this node."
 */
uint64_t RouteHop_get_short_channel_id(const LDKRouteHop *this_ptr);

/**
 * " The channel that should be used from the previous hop to reach this node."
 */
void RouteHop_set_short_channel_id(LDKRouteHop *this_ptr, uint64_t val);

/**
 * " The fee taken on this hop. For the last hop, this should be the full value of the payment."
 */
uint64_t RouteHop_get_fee_msat(const LDKRouteHop *this_ptr);

/**
 * " The fee taken on this hop. For the last hop, this should be the full value of the payment."
 */
void RouteHop_set_fee_msat(LDKRouteHop *this_ptr, uint64_t val);

/**
 * " The CLTV delta added for this hop. For the last hop, this should be the full CLTV value"
 * " expected at the destination, in excess of the current block height."
 */
uint32_t RouteHop_get_cltv_expiry_delta(const LDKRouteHop *this_ptr);

/**
 * " The CLTV delta added for this hop. For the last hop, this should be the full CLTV value"
 * " expected at the destination, in excess of the current block height."
 */
void RouteHop_set_cltv_expiry_delta(LDKRouteHop *this_ptr, uint32_t val);

void Route_free(LDKRoute this_ptr);

/**
 * " The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the"
 * " last RouteHop in each path must be the same."
 * " Each entry represents a list of hops, NOT INCLUDING our own, where the last hop is the"
 * " destination. Thus, this must always be at least length one. While the maximum length of any"
 * " given path is variable, keeping the length of any path to less than 20 should currently"
 * " ensure it is viable."
 */
void Route_set_paths(LDKRoute *this_ptr, LDKCVec_CVec_RouteHopZZ val);

LDKRoute Route_new(LDKCVec_CVec_RouteHopZZ paths_arg);

void RouteHint_free(LDKRouteHint this_ptr);

/**
 * " The node_id of the non-target end of the route"
 */
LDKPublicKey RouteHint_get_src_node_id(const LDKRouteHint *this_ptr);

/**
 * " The node_id of the non-target end of the route"
 */
void RouteHint_set_src_node_id(LDKRouteHint *this_ptr, LDKPublicKey val);

/**
 * " The short_channel_id of this channel"
 */
uint64_t RouteHint_get_short_channel_id(const LDKRouteHint *this_ptr);

/**
 * " The short_channel_id of this channel"
 */
void RouteHint_set_short_channel_id(LDKRouteHint *this_ptr, uint64_t val);

/**
 * " The fees which must be paid to use this channel"
 */
const LDKRoutingFees *RouteHint_get_fees(const LDKRouteHint *this_ptr);

/**
 * " The fees which must be paid to use this channel"
 */
void RouteHint_set_fees(LDKRouteHint *this_ptr, LDKRoutingFees val);

/**
 * " The difference in CLTV values between this node and the next node."
 */
uint16_t RouteHint_get_cltv_expiry_delta(const LDKRouteHint *this_ptr);

/**
 * " The difference in CLTV values between this node and the next node."
 */
void RouteHint_set_cltv_expiry_delta(LDKRouteHint *this_ptr, uint16_t val);

/**
 * " The minimum value, in msat, which must be relayed to the next hop."
 */
uint64_t RouteHint_get_htlc_minimum_msat(const LDKRouteHint *this_ptr);

/**
 * " The minimum value, in msat, which must be relayed to the next hop."
 */
void RouteHint_set_htlc_minimum_msat(LDKRouteHint *this_ptr, uint64_t val);

LDKRouteHint RouteHint_new(LDKPublicKey src_node_id_arg, uint64_t short_channel_id_arg, LDKRoutingFees fees_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg);

void NetGraphMsgHandler_free(LDKNetGraphMsgHandler this_ptr);

/**
 * " Creates a new tracker of the actual state of the network of channels and nodes,"
 * " assuming a fresh network graph."
 * " Chain monitor is used to make sure announced channels exist on-chain,"
 * " channel data is correct, and that the announcement is signed with"
 * " channel owners' keys."
 */
LDKNetGraphMsgHandler NetGraphMsgHandler_new(LDKChainWatchInterface chain_monitor, LDKLogger logger);

LDKRoutingMessageHandler NetGraphMsgHandler_as_RoutingMessageHandler(const LDKNetGraphMsgHandler *this_arg);

void DirectionalChannelInfo_free(LDKDirectionalChannelInfo this_ptr);

/**
 * " When the last update to the channel direction was issued."
 * " Value is opaque, as set in the announcement."
 */
uint32_t DirectionalChannelInfo_get_last_update(const LDKDirectionalChannelInfo *this_ptr);

/**
 * " When the last update to the channel direction was issued."
 * " Value is opaque, as set in the announcement."
 */
void DirectionalChannelInfo_set_last_update(LDKDirectionalChannelInfo *this_ptr, uint32_t val);

/**
 * " Whether the channel can be currently used for payments (in this one direction)."
 */
bool DirectionalChannelInfo_get_enabled(const LDKDirectionalChannelInfo *this_ptr);

/**
 * " Whether the channel can be currently used for payments (in this one direction)."
 */
void DirectionalChannelInfo_set_enabled(LDKDirectionalChannelInfo *this_ptr, bool val);

/**
 * " The difference in CLTV values that you must have when routing through this channel."
 */
uint16_t DirectionalChannelInfo_get_cltv_expiry_delta(const LDKDirectionalChannelInfo *this_ptr);

/**
 * " The difference in CLTV values that you must have when routing through this channel."
 */
void DirectionalChannelInfo_set_cltv_expiry_delta(LDKDirectionalChannelInfo *this_ptr, uint16_t val);

/**
 * " The minimum value, which must be relayed to the next hop via the channel"
 */
uint64_t DirectionalChannelInfo_get_htlc_minimum_msat(const LDKDirectionalChannelInfo *this_ptr);

/**
 * " The minimum value, which must be relayed to the next hop via the channel"
 */
void DirectionalChannelInfo_set_htlc_minimum_msat(LDKDirectionalChannelInfo *this_ptr, uint64_t val);

void ChannelInfo_free(LDKChannelInfo this_ptr);

/**
 * " Source node of the first direction of a channel"
 */
LDKPublicKey ChannelInfo_get_node_one(const LDKChannelInfo *this_ptr);

/**
 * " Source node of the first direction of a channel"
 */
void ChannelInfo_set_node_one(LDKChannelInfo *this_ptr, LDKPublicKey val);

/**
 * " Details about the first direction of a channel"
 */
const LDKDirectionalChannelInfo *ChannelInfo_get_one_to_two(const LDKChannelInfo *this_ptr);

/**
 * " Details about the first direction of a channel"
 */
void ChannelInfo_set_one_to_two(LDKChannelInfo *this_ptr, LDKDirectionalChannelInfo val);

/**
 * " Source node of the second direction of a channel"
 */
LDKPublicKey ChannelInfo_get_node_two(const LDKChannelInfo *this_ptr);

/**
 * " Source node of the second direction of a channel"
 */
void ChannelInfo_set_node_two(LDKChannelInfo *this_ptr, LDKPublicKey val);

/**
 * " Details about the second direction of a channel"
 */
const LDKDirectionalChannelInfo *ChannelInfo_get_two_to_one(const LDKChannelInfo *this_ptr);

/**
 * " Details about the second direction of a channel"
 */
void ChannelInfo_set_two_to_one(LDKChannelInfo *this_ptr, LDKDirectionalChannelInfo val);

void RoutingFees_free(LDKRoutingFees this_ptr);

/**
 * " Flat routing fee in satoshis"
 */
uint32_t RoutingFees_get_base_msat(const LDKRoutingFees *this_ptr);

/**
 * " Flat routing fee in satoshis"
 */
void RoutingFees_set_base_msat(LDKRoutingFees *this_ptr, uint32_t val);

/**
 * " Liquidity-based routing fee in millionths of a routed amount."
 * " In other words, 10000 is 1%."
 */
uint32_t RoutingFees_get_proportional_millionths(const LDKRoutingFees *this_ptr);

/**
 * " Liquidity-based routing fee in millionths of a routed amount."
 * " In other words, 10000 is 1%."
 */
void RoutingFees_set_proportional_millionths(LDKRoutingFees *this_ptr, uint32_t val);

LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);

void NodeAnnouncementInfo_free(LDKNodeAnnouncementInfo this_ptr);

/**
 * " When the last known update to the node state was issued."
 * " Value is opaque, as set in the announcement."
 */
uint32_t NodeAnnouncementInfo_get_last_update(const LDKNodeAnnouncementInfo *this_ptr);

/**
 * " When the last known update to the node state was issued."
 * " Value is opaque, as set in the announcement."
 */
void NodeAnnouncementInfo_set_last_update(LDKNodeAnnouncementInfo *this_ptr, uint32_t val);

/**
 * " Color assigned to the node"
 */
const uint8_t (*NodeAnnouncementInfo_get_rgb(const LDKNodeAnnouncementInfo *this_ptr))[3];

/**
 * " Color assigned to the node"
 */
void NodeAnnouncementInfo_set_rgb(LDKNodeAnnouncementInfo *this_ptr, LDKThreeBytes val);

/**
 * " Moniker assigned to the node."
 * " May be invalid or malicious (eg control chars),"
 * " should not be exposed to the user."
 */
const uint8_t (*NodeAnnouncementInfo_get_alias(const LDKNodeAnnouncementInfo *this_ptr))[32];

/**
 * " Moniker assigned to the node."
 * " May be invalid or malicious (eg control chars),"
 * " should not be exposed to the user."
 */
void NodeAnnouncementInfo_set_alias(LDKNodeAnnouncementInfo *this_ptr, LDKThirtyTwoBytes val);

/**
 * " Internet-level addresses via which one can connect to the node"
 */
void NodeAnnouncementInfo_set_addresses(LDKNodeAnnouncementInfo *this_ptr, LDKCVec_NetAddressZ val);

void NodeInfo_free(LDKNodeInfo this_ptr);

/**
 * " All valid channels a node has announced"
 */
void NodeInfo_set_channels(LDKNodeInfo *this_ptr, LDKCVec_u64Z val);

/**
 * " Lowest fees enabling routing via any of the enabled, known channels to a node."
 * " The two fields (flat and proportional fee) are independent,"
 * " meaning they don't have to refer to the same channel."
 */
const LDKRoutingFees *NodeInfo_get_lowest_inbound_channel_fees(const LDKNodeInfo *this_ptr);

/**
 * " Lowest fees enabling routing via any of the enabled, known channels to a node."
 * " The two fields (flat and proportional fee) are independent,"
 * " meaning they don't have to refer to the same channel."
 */
void NodeInfo_set_lowest_inbound_channel_fees(LDKNodeInfo *this_ptr, LDKRoutingFees val);

/**
 * " More information about a node from node_announcement."
 * " Optional because we store a Node entry after learning about it from"
 * " a channel announcement, but before receiving a node announcement."
 */
const LDKNodeAnnouncementInfo *NodeInfo_get_announcement_info(const LDKNodeInfo *this_ptr);

/**
 * " More information about a node from node_announcement."
 * " Optional because we store a Node entry after learning about it from"
 * " a channel announcement, but before receiving a node announcement."
 */
void NodeInfo_set_announcement_info(LDKNodeInfo *this_ptr, LDKNodeAnnouncementInfo val);

LDKNodeInfo NodeInfo_new(LDKCVec_u64Z channels_arg, LDKRoutingFees lowest_inbound_channel_fees_arg, LDKNodeAnnouncementInfo announcement_info_arg);

void NetworkGraph_free(LDKNetworkGraph this_ptr);

/**
 * " Close a channel if a corresponding HTLC fail was sent."
 * " If permanent, removes a channel from the local storage."
 * " May cause the removal of nodes too, if this was their last channel."
 * " If not permanent, makes channels unavailable for routing."
 */
void NetworkGraph_close_channel_from_update(LDKNetworkGraph *this_arg, uint64_t short_channel_id, bool is_permanent);

/* Text to put at the end of the generated file */
