/* Text to put at the beginning of the generated file. Probably a license. */

/* Generated with cbindgen:0.13.1 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * " An enum that represents the speed at which we want a transaction to confirm used for feerate"
 * " estimation."
 */
typedef enum {
   /**
    * " We are happy with this transaction confirming slowly when feerate drops some."
    */
   Background,
   /**
    * " We'd like this transaction to confirm without major delay, but 12-18 blocks is fine."
    */
   Normal,
   /**
    * " We'd like this transaction to confirm in the next few blocks."
    */
   HighPriority,
} LDKConfirmationTarget;

/**
 * " An enum representing the available verbosity levels of the logger."
 */
typedef enum {
   /**
    * "Designates logger being silent"
    */
   Off,
   /**
    * " Designates very serious errors"
    */
   Error,
   /**
    * " Designates hazardous situations"
    */
   Warn,
   /**
    * " Designates useful information"
    */
   Info,
   /**
    * " Designates lower priority information"
    */
   Debug,
   /**
    * " Designates very low priority, often extremely verbose, information"
    */
   Trace,
} LDKLevel;

typedef enum {
   Bitcoin,
   Testnet,
   Regtest,
} LDKNetwork;

typedef struct LDKPeerManager LDKPeerManager;

typedef struct LDKSocketDescriptor LDKSocketDescriptor;

/**
 * " An Event which you should probably take some action in response to."
 * ""
 * " Note that while Writeable and Readable are implemented for Event, you probably shouldn't use"
 * " them directly as they don't round-trip exactly (for example FundingGenerationReady is never"
 * " written as it makes no sense to respond to it after reconnecting to peers)."
 */
typedef struct {
   const LDKlnEvent *inner;
} LDKEvent;

/**
 * " An event generated by ChannelManager which indicates a message should be sent to a peer (or"
 * " broadcast to most peers)."
 * " These events are handled by PeerManager::process_events if you are using a PeerManager."
 */
typedef struct {
   const LDKlnMessageSendEvent *inner;
} LDKMessageSendEvent;

/**
 * " Indicates an error on the client's part (usually some variant of attempting to use too-low or"
 * " too-high values)"
 */
typedef struct {
   const LDKlnAPIError *inner;
} LDKAPIError;

/**
 * " Top-level config which holds ChannelHandshakeLimits and ChannelConfig."
 * ""
 * " Default::default() provides sane defaults for most configurations"
 * " (but currently with 0 relay fees!)"
 */
typedef struct {
   const LDKlnUserConfig *inner;
} LDKUserConfig;

/**
 * " Configuration we set when applicable."
 * ""
 * " Default::default() provides sane defaults."
 */
typedef struct {
   const LDKlnChannelHandshakeConfig *inner;
} LDKChannelHandshakeConfig;

/**
 * " Optional channel limits which are applied during channel creation."
 * ""
 * " These limits are only applied to our counterparty's limits, not our own."
 * ""
 * " Use 0/<type>::max_value() as appropriate to skip checking."
 * ""
 * " Provides sane defaults for most configurations."
 * ""
 * " Most additional limits are disabled except those with which specify a default in individual"
 * " field documentation. Note that this may result in barely-usable channels, but since they"
 * " are applied mostly only to incoming channels that's not much of a problem."
 */
typedef struct {
   const LDKlnChannelHandshakeLimits *inner;
} LDKChannelHandshakeLimits;

/**
 * " Options which apply on a per-channel basis and may change at runtime or based on negotiation"
 * " with our counterparty."
 */
typedef struct {
   const LDKlnChannelConfig *inner;
} LDKChannelConfig;

/**
 * " A reference to a transaction output."
 * ""
 * " Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32"
 * " due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way."
 */
typedef struct {
   const LDKlnOutPoint *inner;
} LDKOutPoint;

typedef struct {
   uint8_t data[32];
} LDKThirtyTwoBytes;

/**
 * " When on-chain outputs are created by rust-lightning (which our counterparty is not able to"
 * " claim at any point in the future) an event is generated which you must track and be able to"
 * " spend on-chain. The information needed to do this is provided in this enum, including the"
 * " outpoint describing which txid and output index is available, the full output which exists at"
 * " that txid/index, and any keys or other information required to sign."
 */
typedef struct {
   const LDKlnSpendableOutputDescriptor *inner;
} LDKSpendableOutputDescriptor;

/**
 * " A simple implementation of ChannelKeys that just keeps the private keys in memory."
 */
typedef struct {
   const LDKlnInMemoryChannelKeys *inner;
} LDKInMemoryChannelKeys;

/**
 * " Set of lightning keys needed to operate a channel as described in BOLT 3."
 * ""
 * " Signing services could be implemented on a hardware wallet. In this case,"
 * " the current ChannelKeys would be a front-end on top of a communication"
 * " channel connected to your secure device and lightning key material wouldn't"
 * " reside on a hot server. Nevertheless, a this deployment would still need"
 * " to trust the ChannelManager to avoid loss of funds as this latest component"
 * " could ask to sign commitment transaction with HTLCs paying to attacker pubkeys."
 * ""
 * " A more secure iteration would be to use hashlock (or payment points) to pair"
 * " invoice/incoming HTLCs with outgoing HTLCs to implement a no-trust-ChannelManager"
 * " at the price of more state and computation on the hardware wallet side. In the future,"
 * " we are looking forward to design such interface."
 * ""
 * " In any case, ChannelMonitor or fallback watchtowers are always going to be trusted"
 * " to act, as liveness and breach reply correctness are always going to be hard requirements"
 * " of LN security model, orthogonal of key management issues."
 * ""
 * " If you're implementing a custom signer, you almost certainly want to implement"
 * " Readable/Writable to serialize out a unique reference to this set of keys so"
 * " that you can serialize the full ChannelManager object."
 * ""
 */
typedef struct {
   void *this_arg;
} LDKChannelKeys;

/**
 * " Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key"
 * " and derives keys from that."
 * ""
 * " Your node_id is seed/0'"
 * " ChannelMonitor closes may use seed/1'"
 * " Cooperative closes may use seed/2'"
 * " The two close keys may be needed to claim on-chain funds!"
 */
typedef struct {
   const LDKlnKeysManager *inner;
} LDKKeysManager;

/**
 * " A trait encapsulating the operations required of a logger"
 */
typedef struct {
   void *this_arg;
   /**
    * " Logs the `Record`"
    */
   void (*log)(const void *this_arg, const char *record);
} LDKLogger;

typedef struct {
   uint8_t bytes[32];
} LDKSecretKey;

typedef struct {
   uint8_t compressed_form[33];
} LDKPublicKey;

/**
 * " A trait to describe an object which can get user secrets and key material."
 */
typedef struct {
   void *this_arg;
   /**
    * " Get node secret key (aka node_id or network_key)"
    */
   LDKSecretKey (*get_node_secret)(const void *this_arg);
   /**
    * " Get shutdown_pubkey to use as PublicKey at channel closure"
    */
   LDKPublicKey (*get_shutdown_pubkey)(const void *this_arg);
   /**
    * " Get a unique temporary channel id. Channels will be referred to by this until the funding"
    * " transaction is created, at which point they will use the outpoint in the funding"
    * " transaction."
    */
   LDKThirtyTwoBytes (*get_channel_id)(const void *this_arg);
   LDKInMemoryChannelKeys *channel_keys;
} LDKKeysInterface;

/**
 * " Manager which keeps track of a number of channels and sends messages to the appropriate"
 * " channel, also tracking HTLC preimages and forwarding onion packets appropriately."
 * ""
 * " Implements ChannelMessageHandler, handling the multi-channel parts and passing things through"
 * " to individual Channels."
 * ""
 * " Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for"
 * " all peers during write/read (though does not modify this instance, only the instance being"
 * " serialized). This will result in any channels which have not yet exchanged funding_created (ie"
 * " called funding_transaction_generated for outbound channels)."
 * ""
 * " Note that you can be a bit lazier about writing out ChannelManager than you can be with"
 * " ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before"
 * " returning from ManyChannelMonitor::add_/update_monitor, with ChannelManagers, writing updates"
 * " happens out-of-band (and will prevent any other ChannelManager operations from occurring during"
 * " the serialization process). If the deserialized version is out-of-date compared to the"
 * " ChannelMonitors passed by reference to read(), those channels will be force-closed based on the"
 * " ChannelMonitor state and no funds will be lost (mod on-chain transaction fees)."
 * ""
 * " Note that the deserializer is only implemented for (Sha256dHash, ChannelManager), which"
 * " tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along"
 * " the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call"
 * " block_connected() to step towards your best block) upon deserialization before using the"
 * " object!"
 * ""
 * " Note that ChannelManager is responsible for tracking liveness of its channels and generating"
 * " ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid"
 * " spam due to quick disconnection/reconnection, updates are not sent until the channel has been"
 * " offline for a full minute. In order to track this, you must call"
 * " timer_chan_freshness_every_min roughly once per minute, though it doesn't have to be perfect."
 * ""
 * " Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager"
 * " a SimpleRefChannelManager, for conciseness. See their documentation for more details, but"
 * " essentially you should default to using a SimpleRefChannelManager, and use a"
 * " SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when"
 * " you're using lightning-net-tokio."
 */
typedef struct {
   const LDKlnChannelManager *inner;
} LDKChannelManager;

/**
 * " Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels"
 */
typedef struct {
   const LDKlnChannelDetails *inner;
} LDKChannelDetails;

/**
 * " Features used within an `init` message."
 */
typedef struct {
   const LDKlnInitFeatures *inner;
} LDKInitFeatures;

/**
 * " If a payment fails to send, it can be in one of several states. This enum is returned as the"
 * " Err() type describing which state the payment is in, see the description of individual enum"
 * " states for more."
 */
typedef struct {
   const LDKlnPaymentSendFailure *inner;
} LDKPaymentSendFailure;

/**
 * " A trait which should be implemented to provide feerate information on a number of time"
 * " horizons."
 * ""
 * " Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're"
 * " called from inside the library in response to ChainListener events, P2P events, or timer"
 * " events)."
 */
typedef struct {
   void *this_arg;
   /**
    * " Gets estimated satoshis of fee required per 1000 Weight-Units."
    * ""
    * " Must be no smaller than 253 (ie 1 satoshi-per-byte rounded up to ensure later round-downs"
    * " don't put us below 1 satoshi-per-byte)."
    * ""
    * " This translates to:"
    * "  * satoshis-per-byte * 250"
    * "  * ceil(satoshis-per-kbyte / 4)"
    */
   uint64_t (*get_est_sat_per_1000_weight)(const void *this_arg, LDKConfirmationTarget confirmation_target);
} LDKFeeEstimator;

/**
 * " Simple trait indicating ability to track a set of ChannelMonitors and multiplex events between"
 * " them. Generally should be implemented by keeping a local SimpleManyChannelMonitor and passing"
 * " events to it, while also taking any add/update_monitor events and passing them to some remote"
 * " server(s)."
 * ""
 * " In general, you must always have at least one local copy in memory, which must never fail to"
 * " update (as it is responsible for broadcasting the latest state in case the channel is closed),"
 * " and then persist it to various on-disk locations. If, for some reason, the in-memory copy fails"
 * " to update (eg out-of-memory or some other condition), you must immediately shut down without"
 * " taking any further action such as writing the current state to disk. This should likely be"
 * " accomplished via panic!() or abort()."
 * ""
 * " Note that any updates to a channel's monitor *must* be applied to each instance of the"
 * " channel's monitor everywhere (including remote watchtowers) *before* this function returns. If"
 * " an update occurs and a remote watchtower is left with old state, it may broadcast transactions"
 * " which we have revoked, allowing our counterparty to claim all funds in the channel!"
 * ""
 * " User needs to notify implementors of ManyChannelMonitor when a new block is connected or"
 * " disconnected using their `block_connected` and `block_disconnected` methods. However, rather"
 * " than calling these methods directly, the user should register implementors as listeners to the"
 * " BlockNotifier and call the BlockNotifier's `block_(dis)connected` methods, which will notify"
 * " all registered listeners in one go."
 */
typedef struct {
   void *this_arg;
} LDKManyChannelMonitor;

typedef struct {
   const uint8_t *data;
   uintptr_t datalen;
} LDKTransaction;

/**
 * " An interface to send a transaction to the Bitcoin network."
 */
typedef struct {
   void *this_arg;
   /**
    * " Sends a transaction out to (hopefully) be mined."
    */
   void (*broadcast_transaction)(const void *this_arg, LDKTransaction tx);
} LDKBroadcasterInterface;

/**
 * " An open_channel message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnOpenChannel *inner;
} LDKOpenChannel;

/**
 * " An accept_channel message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnAcceptChannel *inner;
} LDKAcceptChannel;

/**
 * " A funding_created message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnFundingCreated *inner;
} LDKFundingCreated;

/**
 * " A funding_signed message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnFundingSigned *inner;
} LDKFundingSigned;

/**
 * " A funding_locked message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnFundingLocked *inner;
} LDKFundingLocked;

/**
 * " A shutdown message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnShutdown *inner;
} LDKShutdown;

/**
 * " A closing_signed message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnClosingSigned *inner;
} LDKClosingSigned;

/**
 * " An update_add_htlc message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateAddHTLC *inner;
} LDKUpdateAddHTLC;

/**
 * " An update_fulfill_htlc message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateFulfillHTLC *inner;
} LDKUpdateFulfillHTLC;

/**
 * " An update_fail_htlc message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateFailHTLC *inner;
} LDKUpdateFailHTLC;

/**
 * " An update_fail_malformed_htlc message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateFailMalformedHTLC *inner;
} LDKUpdateFailMalformedHTLC;

/**
 * " A commitment_signed message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnCommitmentSigned *inner;
} LDKCommitmentSigned;

/**
 * " A revoke_and_ack message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnRevokeAndACK *inner;
} LDKRevokeAndACK;

/**
 * " An update_fee message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateFee *inner;
} LDKUpdateFee;

/**
 * " An announcement_signatures message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnAnnouncementSignatures *inner;
} LDKAnnouncementSignatures;

/**
 * " An init message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnInit *inner;
} LDKInit;

/**
 * " A channel_reestablish message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnChannelReestablish *inner;
} LDKChannelReestablish;

/**
 * " An error message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnErrorMessage *inner;
} LDKErrorMessage;

/**
 * " A trait indicating an object may generate message send events"
 */
typedef struct {
   void *this_arg;
} LDKMessageSendEventsProvider;

/**
 * " A trait to describe an object which can receive channel messages."
 * ""
 * " Messages MAY be called in parallel when they originate from different their_node_ids, however"
 * " they MUST NOT be called in parallel when the two calls have the same their_node_id."
 */
typedef struct {
   void *this_arg;
   /**
    * " Handle an incoming open_channel message from the given peer."
    */
   void (*handle_open_channel)(const void *this_arg, LDKPublicKey their_node_id, LDKInitFeatures their_features, const LDKOpenChannel *msg);
   /**
    * " Handle an incoming accept_channel message from the given peer."
    */
   void (*handle_accept_channel)(const void *this_arg, LDKPublicKey their_node_id, LDKInitFeatures their_features, const LDKAcceptChannel *msg);
   /**
    * " Handle an incoming funding_created message from the given peer."
    */
   void (*handle_funding_created)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingCreated *msg);
   /**
    * " Handle an incoming funding_signed message from the given peer."
    */
   void (*handle_funding_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingSigned *msg);
   /**
    * " Handle an incoming funding_locked message from the given peer."
    */
   void (*handle_funding_locked)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingLocked *msg);
   /**
    * " Handle an incoming shutdown message from the given peer."
    */
   void (*handle_shutdown)(const void *this_arg, LDKPublicKey their_node_id, const LDKShutdown *msg);
   /**
    * " Handle an incoming closing_signed message from the given peer."
    */
   void (*handle_closing_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKClosingSigned *msg);
   /**
    * " Handle an incoming update_add_htlc message from the given peer."
    */
   void (*handle_update_add_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateAddHTLC *msg);
   /**
    * " Handle an incoming update_fulfill_htlc message from the given peer."
    */
   void (*handle_update_fulfill_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFulfillHTLC *msg);
   /**
    * " Handle an incoming update_fail_htlc message from the given peer."
    */
   void (*handle_update_fail_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFailHTLC *msg);
   /**
    * " Handle an incoming update_fail_malformed_htlc message from the given peer."
    */
   void (*handle_update_fail_malformed_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFailMalformedHTLC *msg);
   /**
    * " Handle an incoming commitment_signed message from the given peer."
    */
   void (*handle_commitment_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKCommitmentSigned *msg);
   /**
    * " Handle an incoming revoke_and_ack message from the given peer."
    */
   void (*handle_revoke_and_ack)(const void *this_arg, LDKPublicKey their_node_id, const LDKRevokeAndACK *msg);
   /**
    * " Handle an incoming update_fee message from the given peer."
    */
   void (*handle_update_fee)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFee *msg);
   /**
    * " Handle an incoming announcement_signatures message from the given peer."
    */
   void (*handle_announcement_signatures)(const void *this_arg, LDKPublicKey their_node_id, const LDKAnnouncementSignatures *msg);
   /**
    * " Indicates a connection to the peer failed/an existing connection was lost. If no connection"
    * " is believed to be possible in the future (eg they're sending us messages we don't"
    * " understand or indicate they require unknown feature bits), no_connection_possible is set"
    * " and any outstanding channels should be failed."
    */
   void (*peer_disconnected)(const void *this_arg, LDKPublicKey their_node_id, bool no_connection_possible);
   /**
    * " Handle a peer reconnecting, possibly generating channel_reestablish message(s)."
    */
   void (*peer_connected)(const void *this_arg, LDKPublicKey their_node_id, const LDKInit *msg);
   /**
    * " Handle an incoming channel_reestablish message from the given peer."
    */
   void (*handle_channel_reestablish)(const void *this_arg, LDKPublicKey their_node_id, const LDKChannelReestablish *msg);
   /**
    * " Handle an incoming error message from the given peer."
    */
   void (*handle_error)(const void *this_arg, LDKPublicKey their_node_id, const LDKErrorMessage *msg);
   LDKMessageSendEventsProvider MessageSendEventsProvider;
} LDKChannelMessageHandler;

/**
 * " An update generated by the underlying Channel itself which contains some new information the"
 * " ChannelMonitor should be made aware of."
 */
typedef struct {
   const LDKlnChannelMonitorUpdate *inner;
} LDKChannelMonitorUpdate;

/**
 * " General Err type for ChannelMonitor actions. Generally, this implies that the data provided is"
 * " inconsistent with the ChannelMonitor being called. eg for ChannelMonitor::update_monitor this"
 * " means you tried to update a monitor for a different channel or the ChannelMonitorUpdate was"
 * " corrupted."
 * " Contains a human-readable error message."
 */
typedef struct {
   const LDKlnMonitorUpdateError *inner;
} LDKMonitorUpdateError;

/**
 * " Simple structure send back by ManyChannelMonitor in case of HTLC detected onchain from a"
 * " forward channel and from which info are needed to update HTLC in a backward channel."
 */
typedef struct {
   const LDKlnHTLCUpdate *inner;
} LDKHTLCUpdate;

/**
 * " A ChannelMonitor handles chain events (blocks connected and disconnected) and generates"
 * " on-chain transactions to ensure no loss of funds occurs."
 * ""
 * " You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date"
 * " information and are actively monitoring the chain."
 * ""
 * " Pending Events or updated HTLCs which have not yet been read out by"
 * " get_and_clear_pending_htlcs_updated or get_and_clear_pending_events are serialized to disk and"
 * " reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events"
 * " gotten are fully handled before re-serializing the new state."
 */
typedef struct {
   const LDKlnChannelMonitor *inner;
} LDKChannelMonitor;

/**
 * " An error in decoding a message or struct."
 */
typedef struct {
   const LDKlnDecodeError *inner;
} LDKDecodeError;

/**
 * " A ping message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnPing *inner;
} LDKPing;

/**
 * " A pong message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnPong *inner;
} LDKPong;

/**
 * " An address which can be used to connect to a remote peer"
 */
typedef struct {
   const LDKlnNetAddress *inner;
} LDKNetAddress;

/**
 * " The unsigned part of a node_announcement"
 */
typedef struct {
   const LDKlnUnsignedNodeAnnouncement *inner;
} LDKUnsignedNodeAnnouncement;

/**
 * " A node_announcement message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnNodeAnnouncement *inner;
} LDKNodeAnnouncement;

/**
 * " The unsigned part of a channel_announcement"
 */
typedef struct {
   const LDKlnUnsignedChannelAnnouncement *inner;
} LDKUnsignedChannelAnnouncement;

/**
 * " A channel_announcement message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnChannelAnnouncement *inner;
} LDKChannelAnnouncement;

/**
 * " A channel_update message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnChannelUpdate *inner;
} LDKChannelUpdate;

/**
 * " An Err type for failure to process messages."
 */
typedef struct {
   const LDKlnLightningError *inner;
} LDKLightningError;

/**
 * " Struct used to return values from revoke_and_ack messages, containing a bunch of commitment"
 * " transaction updates if they were pending."
 */
typedef struct {
   const LDKlnCommitmentUpdate *inner;
} LDKCommitmentUpdate;

/**
 * " The information we received from a peer along the route of a payment we originated. This is"
 * " returned by ChannelMessageHandler::handle_update_fail_htlc to be passed into"
 * " RoutingMessageHandler::handle_htlc_fail_channel_update to update our network map."
 */
typedef struct {
   const LDKlnHTLCFailChannelUpdate *inner;
} LDKHTLCFailChannelUpdate;

/**
 * " The set of public keys which are used in the creation of one commitment transaction."
 * " These are derived from the channel base keys and per-commitment data."
 */
typedef struct {
   const LDKlnTxCreationKeys *inner;
} LDKTxCreationKeys;

/**
 * " One counterparty's public keys which do not change over the life of a channel."
 */
typedef struct {
   const LDKlnChannelPublicKeys *inner;
} LDKChannelPublicKeys;

/**
 * " Information about an HTLC as it appears in a commitment transaction"
 */
typedef struct {
   const LDKlnHTLCOutputInCommitment *inner;
} LDKHTLCOutputInCommitment;

/**
 * " Features used within a `node_announcement` message."
 */
typedef struct {
   const LDKlnNodeFeatures *inner;
} LDKNodeFeatures;

/**
 * " Features used within a `channel_announcement` message."
 */
typedef struct {
   const LDKlnChannelFeatures *inner;
} LDKChannelFeatures;

typedef struct {
   char *message;
   uintptr_t length;
} LDKError;

/**
 * " Provides references to trait impls which handle different types of messages."
 */
typedef struct {
   const LDKlnMessageHandler *inner;
} LDKMessageHandler;

/**
 * " A trait to describe an object which can receive routing messages."
 */
typedef struct {
   void *this_arg;
   /**
    * " Returns whether a full sync should be requested from a peer."
    */
   bool (*should_request_full_sync)(const void *this_arg, LDKPublicKey node_id);
} LDKRoutingMessageHandler;

typedef struct {
   uint8_t *data;
   uintptr_t length;
} LDKBufferResponse;

typedef struct {
   const uint8_t *data;
   uintptr_t length;
} LDKBufferArgument;

void Event_free(LDKEvent this_ptr);

void MessageSendEvent_free(LDKMessageSendEvent this_ptr);

void APIError_free(LDKAPIError this_ptr);

/**
 * " Returns the most verbose logging level."
 */
LDKLevel Level_max(void);

void UserConfig_free(LDKUserConfig this_ptr);

LDKUserConfig UserConfig_default(void);

void ChannelHandshakeConfig_free(LDKChannelHandshakeConfig this_ptr);

/**
 * " Confirmations we will wait for before considering the channel locked in."
 * " Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the"
 * " equivalent limit applied to outbound channels)."
 * ""
 * " Default value: 6."
 */
void ChannelHandshakeConfig_set_minimum_depth(LDKChannelHandshakeConfig *this_ptr, uint32_t val);

/**
 * " Set to the amount of time we require our counterparty to wait to claim their money."
 * ""
 * " It's one of the main parameter of our security model. We (or one of our watchtowers) MUST"
 * " be online to check for peer having broadcast a revoked transaction to steal our funds"
 * " at least once every our_to_self_delay blocks."
 * ""
 * " Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in"
 * " case of an honest unilateral channel close, which implicitly decrease the economic value of"
 * " our channel."
 * ""
 * " Default value: BREAKDOWN_TIMEOUT (currently 144), we enforce it as a minimum at channel"
 * " opening so you can tweak config to ask for more security, not less."
 */
void ChannelHandshakeConfig_set_our_to_self_delay(LDKChannelHandshakeConfig *this_ptr, uint16_t val);

/**
 * " Set to the smallest value HTLC we will accept to process."
 * ""
 * " This value is sent to our counterparty on channel-open and we close the channel any time"
 * " our counterparty misbehaves by sending us an HTLC with a value smaller than this."
 * ""
 * " Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required"
 * " by the protocol."
 */
void ChannelHandshakeConfig_set_our_htlc_minimum_msat(LDKChannelHandshakeConfig *this_ptr, uint64_t val);

LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg);

LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);

void ChannelHandshakeLimits_free(LDKChannelHandshakeLimits this_ptr);

/**
 * " Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so"
 * " only applies to inbound channels."
 * ""
 * " Default value: 0."
 */
void ChannelHandshakeLimits_set_min_funding_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows"
 * " you to limit the maximum minimum-size they can require."
 * ""
 * " Default value: u64::max_value."
 */
void ChannelHandshakeLimits_set_max_htlc_minimum_msat(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " The remote node sets a limit on the maximum value of pending HTLCs to them at any given"
 * " time to limit their funds exposure to HTLCs. This allows you to set a minimum such value."
 * ""
 * " Default value: 0."
 */
void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " The remote node will require we keep a certain amount in direct payment to ourselves at all"
 * " time, ensuring that we are able to be punished if we broadcast an old state. This allows to"
 * " you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs)."
 * ""
 * " Default value: u64::max_value."
 */
void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " The remote node sets a limit on the maximum number of pending HTLCs to them at any given"
 * " time. This allows you to set a minimum such value."
 * ""
 * " Default value: 0."
 */
void ChannelHandshakeLimits_set_min_max_accepted_htlcs(LDKChannelHandshakeLimits *this_ptr, uint16_t val);

/**
 * " Outputs below a certain value will not be added to on-chain transactions. The dust value is"
 * " required to always be higher than this value so this only applies to HTLC outputs (and"
 * " potentially to-self outputs before any payments have been made)."
 * " Thus, HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain."
 * " This setting allows you to set a minimum dust limit for their commitment transactions,"
 * " reflecting the reality that tiny outputs are not considered standard transactions and will"
 * " not propagate through the Bitcoin network."
 * ""
 * " Default value: 546, the current dust limit on the Bitcoin network."
 */
void ChannelHandshakeLimits_set_min_dust_limit_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " Maximum allowed threshold above which outputs will not be generated in their commitment"
 * " transactions."
 * " HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain."
 * ""
 * " Default value: u64::max_value."
 */
void ChannelHandshakeLimits_set_max_dust_limit_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

/**
 * " Before a channel is usable the funding transaction will need to be confirmed by at least a"
 * " certain number of blocks, specified by the node which is not the funder (as the funder can"
 * " assume they aren't going to double-spend themselves)."
 * " This config allows you to set a limit on the maximum amount of time to wait."
 * ""
 * " Default value: 144, or roughly one day and only applies to outbound channels."
 */
void ChannelHandshakeLimits_set_max_minimum_depth(LDKChannelHandshakeLimits *this_ptr, uint32_t val);

/**
 * " Set to force the incoming channel to match our announced channel preference in"
 * " ChannelConfig."
 * ""
 * " Default value: true, to make the default that no announced channels are possible (which is"
 * " appropriate for any nodes which are not online very reliably)."
 */
void ChannelHandshakeLimits_set_force_announced_channel_preference(LDKChannelHandshakeLimits *this_ptr, bool val);

/**
 * " Set to the amount of time we're willing to wait to claim money back to us."
 * ""
 * " Not checking this value would be a security issue, as our peer would be able to set it to"
 * " max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time."
 * ""
 * " Default value: MAX_LOCAL_BREAKDOWN_TIMEOUT (1008), which we also enforce as a maximum value"
 * " so you can tweak config to reduce the loss of having useless locked funds (if your peer accepts)"
 */
void ChannelHandshakeLimits_set_their_to_self_delay(LDKChannelHandshakeLimits *this_ptr, uint16_t val);

LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint64_t min_dust_limit_satoshis_arg, uint64_t max_dust_limit_satoshis_arg, uint32_t max_minimum_depth_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);

LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);

void ChannelConfig_free(LDKChannelConfig this_ptr);

/**
 * " Amount (in millionths of a satoshi) the channel will charge per transferred satoshi."
 * " This may be allowed to change at runtime in a later update, however doing so must result in"
 * " update messages sent to notify all nodes of our updated relay fee."
 * ""
 * " Default value: 0."
 */
void ChannelConfig_set_fee_proportional_millionths(LDKChannelConfig *this_ptr, uint32_t val);

/**
 * " Set to announce the channel publicly and notify all nodes that they can route via this"
 * " channel."
 * ""
 * " This should only be set to true for nodes which expect to be online reliably."
 * ""
 * " As the node which funds a channel picks this value this will only apply for new outbound"
 * " channels unless ChannelHandshakeLimits::force_announced_channel_preferences is set."
 * ""
 * " This cannot be changed after the initial channel handshake."
 * ""
 * " Default value: false."
 */
void ChannelConfig_set_announced_channel(LDKChannelConfig *this_ptr, bool val);

/**
 * " When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty"
 * " supports it, they will then enforce the mutual-close output to us matches what we provided"
 * " at intialization, preventing us from closing to an alternate pubkey."
 * ""
 * " This is set to true by default to provide a slight increase in security, though ultimately"
 * " any attacker who is able to take control of a channel can just as easily send the funds via"
 * " lightning payments, so we never require that our counterparties support this option."
 * ""
 * " This cannot be changed after a channel has been initialized."
 * ""
 * " Default value: true."
 */
void ChannelConfig_set_commit_upfront_shutdown_pubkey(LDKChannelConfig *this_ptr, bool val);

LDKChannelConfig ChannelConfig_new(uint32_t fee_proportional_millionths_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg);

LDKChannelConfig ChannelConfig_default(void);

void OutPoint_free(LDKOutPoint this_ptr);

/**
 * " The referenced transaction's txid."
 */
const uint8_t (*OutPoint_get_txid(const LDKOutPoint *this_ptr))[32];

/**
 * " The referenced transaction's txid."
 */
void OutPoint_set_txid(LDKOutPoint *this_ptr, uint8_t val[32]);

/**
 * " The index of the referenced output in its transaction's vout."
 */
void OutPoint_set_index(LDKOutPoint *this_ptr, uint16_t val);

LDKOutPoint OutPoint_new(uint8_t txid_arg[32], uint16_t index_arg);

/**
 * " Convert an `OutPoint` to a lightning channel id."
 */
LDKThirtyTwoBytes OutPoint_to_channel_id(const LDKOutPoint *this_arg);

void SpendableOutputDescriptor_free(LDKSpendableOutputDescriptor this_ptr);

void InMemoryChannelKeys_free(LDKInMemoryChannelKeys this_ptr);

LDKChannelKeys InMemoryChannelKeys_as_ChannelKeys(const LDKInMemoryChannelKeys *this_arg);

void KeysManager_free(LDKKeysManager this_ptr);

/**
 * " Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your"
 * " RNG is busted) this may panic (but more importantly, you will possibly lose funds)."
 * " starting_time isn't strictly required to actually be a time, but it must absolutely,"
 * " without a doubt, be unique to this instance. ie if you start multiple times with the same"
 * " seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to"
 * " simply use the current time (with very high precision)."
 * ""
 * " The seed MUST be backed up safely prior to use so that the keys can be re-created, however,"
 * " obviously, starting_time should be unique every time you reload the library - it is only"
 * " used to generate new ephemeral key data (which will be stored by the individual channel if"
 * " necessary)."
 * ""
 * " Note that the seed is required to recover certain on-chain funds independent of"
 * " ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any"
 * " channel, and some on-chain during-closing funds."
 * ""
 * " Note that until the 0.1 release there is no guarantee of backward compatibility between"
 * " versions. Once the library is more fully supported, the docs will be updated to include a"
 * " detailed description of the guarantee."
 */
LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], LDKNetwork network, LDKLogger logger, uint64_t starting_time_secs, uint32_t starting_time_nanos);

LDKKeysInterface KeysManager_as_KeysInterface(const LDKKeysManager *this_arg);

void ChannelManager_free(LDKChannelManager this_ptr);

void ChannelDetails_free(LDKChannelDetails this_ptr);

/**
 * " The channel's ID (prior to funding transaction generation, this is a random 32 bytes,"
 * " thereafter this is the txid of the funding transaction xor the funding transaction output)."
 * " Note that this means this value is *not* persistent - it can change once during the"
 * " lifetime of the channel."
 */
const uint8_t (*ChannelDetails_get_channel_id(const LDKChannelDetails *this_ptr))[32];

/**
 * " The channel's ID (prior to funding transaction generation, this is a random 32 bytes,"
 * " thereafter this is the txid of the funding transaction xor the funding transaction output)."
 * " Note that this means this value is *not* persistent - it can change once during the"
 * " lifetime of the channel."
 */
void ChannelDetails_set_channel_id(LDKChannelDetails *this_ptr, LDKThirtyTwoBytes val);

/**
 * " The node_id of our counterparty"
 */
LDKPublicKey ChannelDetails_get_remote_network_id(const LDKChannelDetails *this_ptr);

/**
 * " The node_id of our counterparty"
 */
void ChannelDetails_set_remote_network_id(LDKChannelDetails *this_ptr, LDKPublicKey val);

/**
 * " The Features the channel counterparty provided upon last connection."
 * " Useful for routing as it is the most up-to-date copy of the counterparty's features and"
 * " many routing-relevant features are present in the init context."
 */
const LDKInitFeatures *ChannelDetails_get_counterparty_features(const LDKChannelDetails *this_ptr);

/**
 * " The Features the channel counterparty provided upon last connection."
 * " Useful for routing as it is the most up-to-date copy of the counterparty's features and"
 * " many routing-relevant features are present in the init context."
 */
void ChannelDetails_set_counterparty_features(LDKChannelDetails *this_ptr, LDKInitFeatures val);

/**
 * " The value, in satoshis, of this channel as appears in the funding output"
 */
void ChannelDetails_set_channel_value_satoshis(LDKChannelDetails *this_ptr, uint64_t val);

/**
 * " The user_id passed in to create_channel, or 0 if the channel was inbound."
 */
void ChannelDetails_set_user_id(LDKChannelDetails *this_ptr, uint64_t val);

/**
 * " The available outbound capacity for sending HTLCs to the remote peer. This does not include"
 * " any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not"
 * " available for inclusion in new outbound HTLCs). This further does not include any pending"
 * " outgoing HTLCs which are awaiting some other resolution to be sent."
 */
void ChannelDetails_set_outbound_capacity_msat(LDKChannelDetails *this_ptr, uint64_t val);

/**
 * " The available inbound capacity for the remote peer to send HTLCs to us. This does not"
 * " include any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not"
 * " available for inclusion in new inbound HTLCs)."
 * " Note that there are some corner cases not fully handled here, so the actual available"
 * " inbound capacity may be slightly higher than this."
 */
void ChannelDetails_set_inbound_capacity_msat(LDKChannelDetails *this_ptr, uint64_t val);

/**
 * " True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)"
 * " the peer is connected, and (c) no monitor update failure is pending resolution."
 */
void ChannelDetails_set_is_live(LDKChannelDetails *this_ptr, bool val);

void PaymentSendFailure_free(LDKPaymentSendFailure this_ptr);

/**
 * " Constructs a new ChannelManager to hold several channels and route between them."
 * ""
 * " This is the main \"logic hub\" for all channel-related actions, and implements"
 * " ChannelMessageHandler."
 * ""
 * " Non-proportional fees are fixed according to our risk using the provided fee estimator."
 * ""
 * " panics if channel_value_satoshis is >= `MAX_FUNDING_SATOSHIS`!"
 * ""
 * " Users must provide the current blockchain height from which to track onchain channel"
 * " funding outpoints and send payments with reliable timelocks."
 * ""
 * " Users need to notify the new ChannelManager when a new block is connected or"
 * " disconnected using its `block_connected` and `block_disconnected` methods."
 * " However, rather than calling these methods directly, the user should register"
 * " the ChannelManager as a listener to the BlockNotifier and call the BlockNotifier's"
 * " `block_(dis)connected` methods, which will notify all registered listeners in one"
 * " go."
 */
LDKChannelManager ChannelManager_new(LDKNetwork network, LDKFeeEstimator fee_est, LDKManyChannelMonitor monitor, LDKBroadcasterInterface tx_broadcaster, LDKLogger logger, LDKKeysInterface keys_manager, LDKUserConfig config, uintptr_t current_blockchain_height);

/**
 * " Force closes a channel, immediately broadcasting the latest local commitment transaction to"
 * " the chain and rejecting new HTLCs on the given channel."
 */
void ChannelManager_force_close_channel(const LDKChannelManager *this_arg, const uint8_t (*channel_id)[32]);

/**
 * " Force close all channels, immediately broadcasting the latest local commitment transaction"
 * " for each to the chain and rejecting new HTLCs on each."
 */
void ChannelManager_force_close_all_channels(const LDKChannelManager *this_arg);

/**
 * " Processes HTLCs which are pending waiting on random forward delay."
 * ""
 * " Should only really ever be called in response to a PendingHTLCsForwardable event."
 * " Will likely generate further events."
 */
void ChannelManager_process_pending_htlc_forwards(const LDKChannelManager *this_arg);

/**
 * " If a peer is disconnected we mark any channels with that peer as 'disabled'."
 * " After some time, if channels are still disabled we need to broadcast a ChannelUpdate"
 * " to inform the network about the uselessness of these channels."
 * ""
 * " This method handles all the details, and must be called roughly once per minute."
 */
void ChannelManager_timer_chan_freshness_every_min(const LDKChannelManager *this_arg);

/**
 * " Gets the node_id held by this ChannelManager"
 */
LDKPublicKey ChannelManager_get_our_node_id(const LDKChannelManager *this_arg);

LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const LDKChannelManager *this_arg);

void ChannelMonitorUpdate_free(LDKChannelMonitorUpdate this_ptr);

/**
 * " The sequence number of this update. Updates *must* be replayed in-order according to this"
 * " sequence number (and updates may panic if they are not). The update_id values are strictly"
 * " increasing and increase by one for each new update."
 * ""
 * " This sequence number is also used to track up to which points updates which returned"
 * " ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given"
 * " ChannelMonitor when ChannelManager::channel_monitor_updated is called."
 */
void ChannelMonitorUpdate_set_update_id(LDKChannelMonitorUpdate *this_ptr, uint64_t val);

void MonitorUpdateError_free(LDKMonitorUpdateError this_ptr);

void HTLCUpdate_free(LDKHTLCUpdate this_ptr);

void ChannelMonitor_free(LDKChannelMonitor this_ptr);

/**
 * " Gets the update_id from the latest ChannelMonitorUpdate which was applied to this"
 * " ChannelMonitor."
 */
uint64_t ChannelMonitor_get_latest_update_id(const LDKChannelMonitor *this_arg);

void DecodeError_free(LDKDecodeError this_ptr);

void Init_free(LDKInit this_ptr);

void ErrorMessage_free(LDKErrorMessage this_ptr);

void Ping_free(LDKPing this_ptr);

void Pong_free(LDKPong this_ptr);

void OpenChannel_free(LDKOpenChannel this_ptr);

void AcceptChannel_free(LDKAcceptChannel this_ptr);

void FundingCreated_free(LDKFundingCreated this_ptr);

void FundingSigned_free(LDKFundingSigned this_ptr);

void FundingLocked_free(LDKFundingLocked this_ptr);

const uint8_t (*FundingLocked_get_channel_id(const LDKFundingLocked *this_ptr))[32];

void FundingLocked_set_channel_id(LDKFundingLocked *this_ptr, LDKThirtyTwoBytes val);

LDKPublicKey FundingLocked_get_next_per_commitment_point(const LDKFundingLocked *this_ptr);

void FundingLocked_set_next_per_commitment_point(LDKFundingLocked *this_ptr, LDKPublicKey val);

LDKFundingLocked FundingLocked_new(LDKThirtyTwoBytes channel_id_arg, LDKPublicKey next_per_commitment_point_arg);

void Shutdown_free(LDKShutdown this_ptr);

void ClosingSigned_free(LDKClosingSigned this_ptr);

void UpdateAddHTLC_free(LDKUpdateAddHTLC this_ptr);

void UpdateFulfillHTLC_free(LDKUpdateFulfillHTLC this_ptr);

void UpdateFailHTLC_free(LDKUpdateFailHTLC this_ptr);

void UpdateFailMalformedHTLC_free(LDKUpdateFailMalformedHTLC this_ptr);

void CommitmentSigned_free(LDKCommitmentSigned this_ptr);

void RevokeAndACK_free(LDKRevokeAndACK this_ptr);

void UpdateFee_free(LDKUpdateFee this_ptr);

void ChannelReestablish_free(LDKChannelReestablish this_ptr);

void AnnouncementSignatures_free(LDKAnnouncementSignatures this_ptr);

void NetAddress_free(LDKNetAddress this_ptr);

void UnsignedNodeAnnouncement_free(LDKUnsignedNodeAnnouncement this_ptr);

/**
 * " The node_id this announcement originated from (don't rebroadcast the node_announcement back"
 * " to this node)."
 */
LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const LDKUnsignedNodeAnnouncement *this_ptr);

/**
 * " The node_id this announcement originated from (don't rebroadcast the node_announcement back"
 * " to this node)."
 */
void UnsignedNodeAnnouncement_set_node_id(LDKUnsignedNodeAnnouncement *this_ptr, LDKPublicKey val);

void NodeAnnouncement_free(LDKNodeAnnouncement this_ptr);

void UnsignedChannelAnnouncement_free(LDKUnsignedChannelAnnouncement this_ptr);

/**
 * " One of the two node_ids which are endpoints of this channel"
 */
LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const LDKUnsignedChannelAnnouncement *this_ptr);

/**
 * " One of the two node_ids which are endpoints of this channel"
 */
void UnsignedChannelAnnouncement_set_node_id_1(LDKUnsignedChannelAnnouncement *this_ptr, LDKPublicKey val);

/**
 * " The other of the two node_ids which are endpoints of this channel"
 */
LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const LDKUnsignedChannelAnnouncement *this_ptr);

/**
 * " The other of the two node_ids which are endpoints of this channel"
 */
void UnsignedChannelAnnouncement_set_node_id_2(LDKUnsignedChannelAnnouncement *this_ptr, LDKPublicKey val);

void ChannelAnnouncement_free(LDKChannelAnnouncement this_ptr);

void ChannelUpdate_free(LDKChannelUpdate this_ptr);

void LightningError_free(LDKLightningError this_ptr);

void CommitmentUpdate_free(LDKCommitmentUpdate this_ptr);

/**
 * " Finally, the commitment_signed message which should be sent"
 */
const LDKCommitmentSigned *CommitmentUpdate_get_commitment_signed(const LDKCommitmentUpdate *this_ptr);

/**
 * " Finally, the commitment_signed message which should be sent"
 */
void CommitmentUpdate_set_commitment_signed(LDKCommitmentUpdate *this_ptr, LDKCommitmentSigned val);

void HTLCFailChannelUpdate_free(LDKHTLCFailChannelUpdate this_ptr);

void TxCreationKeys_free(LDKTxCreationKeys this_ptr);

/**
 * " The per-commitment public key which was used to derive the other keys."
 */
LDKPublicKey TxCreationKeys_get_per_commitment_point(const LDKTxCreationKeys *this_ptr);

/**
 * " The per-commitment public key which was used to derive the other keys."
 */
void TxCreationKeys_set_per_commitment_point(LDKTxCreationKeys *this_ptr, LDKPublicKey val);

void ChannelPublicKeys_free(LDKChannelPublicKeys this_ptr);

/**
 * " The public key which is used to sign all commitment transactions, as it appears in the"
 * " on-chain channel lock-in 2-of-2 multisig output."
 */
LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const LDKChannelPublicKeys *this_ptr);

/**
 * " The public key which is used to sign all commitment transactions, as it appears in the"
 * " on-chain channel lock-in 2-of-2 multisig output."
 */
void ChannelPublicKeys_set_funding_pubkey(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

/**
 * " The base point which is used (with derive_public_revocation_key) to derive per-commitment"
 * " revocation keys. The per-commitment revocation private key is then revealed by the owner of"
 * " a commitment transaction so that their counterparty can claim all available funds if they"
 * " broadcast an old state."
 */
LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const LDKChannelPublicKeys *this_ptr);

/**
 * " The base point which is used (with derive_public_revocation_key) to derive per-commitment"
 * " revocation keys. The per-commitment revocation private key is then revealed by the owner of"
 * " a commitment transaction so that their counterparty can claim all available funds if they"
 * " broadcast an old state."
 */
void ChannelPublicKeys_set_revocation_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

/**
 * " The public key which receives our immediately spendable primary channel balance in"
 * " remote-broadcasted commitment transactions. This key is static across every commitment"
 * " transaction."
 */
LDKPublicKey ChannelPublicKeys_get_payment_point(const LDKChannelPublicKeys *this_ptr);

/**
 * " The public key which receives our immediately spendable primary channel balance in"
 * " remote-broadcasted commitment transactions. This key is static across every commitment"
 * " transaction."
 */
void ChannelPublicKeys_set_payment_point(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

/**
 * " The base point which is used (with derive_public_key) to derive a per-commitment payment"
 * " public key which receives non-HTLC-encumbered funds which are only available for spending"
 * " after some delay (or can be claimed via the revocation path)."
 */
LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const LDKChannelPublicKeys *this_ptr);

/**
 * " The base point which is used (with derive_public_key) to derive a per-commitment payment"
 * " public key which receives non-HTLC-encumbered funds which are only available for spending"
 * " after some delay (or can be claimed via the revocation path)."
 */
void ChannelPublicKeys_set_delayed_payment_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

/**
 * " The base point which is used (with derive_public_key) to derive a per-commitment public key"
 * " which is used to encumber HTLC-in-flight outputs."
 */
LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const LDKChannelPublicKeys *this_ptr);

/**
 * " The base point which is used (with derive_public_key) to derive a per-commitment public key"
 * " which is used to encumber HTLC-in-flight outputs."
 */
void ChannelPublicKeys_set_htlc_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

LDKChannelPublicKeys ChannelPublicKeys_new(LDKPublicKey funding_pubkey_arg, LDKPublicKey revocation_basepoint_arg, LDKPublicKey payment_point_arg, LDKPublicKey delayed_payment_basepoint_arg, LDKPublicKey htlc_basepoint_arg);

void HTLCOutputInCommitment_free(LDKHTLCOutputInCommitment this_ptr);

/**
 * " Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction)."
 * " Note that this is not the same as whether it is ountbound *from us*. To determine that you"
 * " need to compare this value to whether the commitment transaction in question is that of"
 * " the remote party or our own."
 */
void HTLCOutputInCommitment_set_offered(LDKHTLCOutputInCommitment *this_ptr, bool val);

/**
 * " The value, in msat, of the HTLC. The value as it appears in the commitment transaction is"
 * " this divided by 1000."
 */
void HTLCOutputInCommitment_set_amount_msat(LDKHTLCOutputInCommitment *this_ptr, uint64_t val);

/**
 * " The CLTV lock-time at which this HTLC expires."
 */
void HTLCOutputInCommitment_set_cltv_expiry(LDKHTLCOutputInCommitment *this_ptr, uint32_t val);

void InitFeatures_free(LDKInitFeatures this_ptr);

void NodeFeatures_free(LDKNodeFeatures this_ptr);

void ChannelFeatures_free(LDKChannelFeatures this_ptr);

LDKInMemoryChannelKeys *in_memory_channel_keys_create(const uint8_t *funding_key, const uint8_t *revocation_base_key, const uint8_t *payment_key, const uint8_t *delayed_payment_base_key, const uint8_t *htlc_base_key, const uint8_t *commitment_seed, uint64_t channel_value_satoshis);

void channel_manager_open_channel(const LDKChannelManager *this_arg, const uint8_t *their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, uint64_t user_id, LDKError *error);

void get_tx_creation_keys(void);

void socket_descriptor_free(LDKSocketDescriptor *raw_socket_descriptor);

void MessageHandler_free(LDKMessageHandler this_ptr);

const LDKChannelMessageHandler *MessageHandler_get_chan_handler(const LDKMessageHandler *this_ptr);

void MessageHandler_set_chan_handler(LDKMessageHandler *this_ptr, LDKChannelMessageHandler val);

const LDKRoutingMessageHandler *MessageHandler_get_route_handler(const LDKMessageHandler *this_ptr);

void MessageHandler_set_route_handler(LDKMessageHandler *this_ptr, LDKRoutingMessageHandler val);

LDKMessageHandler MessageHandler_new(LDKChannelMessageHandler chan_handler_arg, LDKRoutingMessageHandler route_handler_arg);

LDKPeerManager *peer_manager_create(const uint8_t *node_private_key, const uint8_t *ephemeral_seed, LDKMessageHandler message_handler, LDKLogger logger);

LDKSocketDescriptor *peer_manager_new_outbound(LDKPeerManager *peer_manager, const uint8_t *remote_public_key, const void *peer_instance_pointer, uintptr_t (*socket_callback)(const void*, LDKBufferResponse*), void (*disconnect_callback)(const void*), LDKError *error);

void peer_read(LDKPeerManager *peer_manager, const LDKSocketDescriptor *socket_descriptor, const LDKBufferArgument *data);

void peer_force_tick(LDKPeerManager *peer_manager);

LDKBufferResponse peer_manager_try_direct(LDKPeerManager *peer_manager);

void peer_manager_free(LDKPeerManager *raw_peer_manager);

void buffer_response_free(LDKBufferResponse *raw_buffer);

LDKBufferResponse *private_key_to_public_key(const uint8_t *private_key);

bool is_public_key(const uint8_t *public_key);

/* Text to put at the end of the generated file */
