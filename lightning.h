/* Text to put at the beginning of the generated file. Probably a license. */

/* Generated with cbindgen:0.14.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * " An enum that represents the speed at which we want a transaction to confirm used for feerate"
 * " estimation."
 */
typedef enum {
   /**
    * " We are happy with this transaction confirming slowly when feerate drops some."
    */
   Background,
   /**
    * " We'd like this transaction to confirm without major delay, but 12-18 blocks is fine."
    */
   Normal,
   /**
    * " We'd like this transaction to confirm in the next few blocks."
    */
   HighPriority,
} LDKConfirmationTarget;

/**
 * " An enum representing the available verbosity levels of the logger."
 */
typedef enum {
   /**
    * "Designates logger being silent"
    */
   Off,
   /**
    * " Designates very serious errors"
    */
   Error,
   /**
    * " Designates hazardous situations"
    */
   Warn,
   /**
    * " Designates useful information"
    */
   Info,
   /**
    * " Designates lower priority information"
    */
   Debug,
   /**
    * " Designates very low priority, often extremely verbose, information"
    */
   Trace,
} LDKLevel;

typedef enum {
   Bitcoin,
   Testnet,
   Regtest,
} LDKNetwork;

/**
 * " An Event which you should probably take some action in response to."
 * ""
 * " Note that while Writeable and Readable are implemented for Event, you probably shouldn't use"
 * " them directly as they don't round-trip exactly (for example FundingGenerationReady is never"
 * " written as it makes no sense to respond to it after reconnecting to peers)."
 */
typedef struct {
   const LDKlnEvent *inner;
} LDKEvent;

/**
 * " An event generated by ChannelManager which indicates a message should be sent to a peer (or"
 * " broadcast to most peers)."
 * " These events are handled by PeerManager::process_events if you are using a PeerManager."
 */
typedef struct {
   const LDKlnMessageSendEvent *inner;
} LDKMessageSendEvent;

/**
 * " Indicates an error on the client's part (usually some variant of attempting to use too-low or"
 * " too-high values)"
 */
typedef struct {
   const LDKlnAPIError *inner;
} LDKAPIError;

/**
 * " Top-level config which holds ChannelHandshakeLimits and ChannelConfig."
 * ""
 * " Default::default() provides sane defaults for most configurations"
 * " (but currently with 0 relay fees!)"
 */
typedef struct {
   const LDKlnUserConfig *inner;
} LDKUserConfig;

/**
 * " Configuration we set when applicable."
 * ""
 * " Default::default() provides sane defaults."
 */
typedef struct {
   const LDKlnChannelHandshakeConfig *inner;
} LDKChannelHandshakeConfig;

/**
 * " Optional channel limits which are applied during channel creation."
 * ""
 * " These limits are only applied to our counterparty's limits, not our own."
 * ""
 * " Use 0/<type>::max_value() as appropriate to skip checking."
 * ""
 * " Provides sane defaults for most configurations."
 * ""
 * " Most additional limits are disabled except those with which specify a default in individual"
 * " field documentation. Note that this may result in barely-usable channels, but since they"
 * " are applied mostly only to incoming channels that's not much of a problem."
 */
typedef struct {
   const LDKlnChannelHandshakeLimits *inner;
} LDKChannelHandshakeLimits;

/**
 * " Options which apply on a per-channel basis and may change at runtime or based on negotiation"
 * " with our counterparty."
 */
typedef struct {
   const LDKlnChannelConfig *inner;
} LDKChannelConfig;

/**
 * " A reference to a transaction output."
 * ""
 * " Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32"
 * " due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way."
 */
typedef struct {
   const LDKlnOutPoint *inner;
} LDKOutPoint;

typedef struct {
   uint8_t data[32];
} LDKThirtyTwoBytes;

/**
 * " When on-chain outputs are created by rust-lightning (which our counterparty is not able to"
 * " claim at any point in the future) an event is generated which you must track and be able to"
 * " spend on-chain. The information needed to do this is provided in this enum, including the"
 * " outpoint describing which txid and output index is available, the full output which exists at"
 * " that txid/index, and any keys or other information required to sign."
 */
typedef struct {
   const LDKlnSpendableOutputDescriptor *inner;
} LDKSpendableOutputDescriptor;

/**
 * " A simple implementation of ChannelKeys that just keeps the private keys in memory."
 */
typedef struct {
   const LDKlnInMemoryChannelKeys *inner;
} LDKInMemoryChannelKeys;

/**
 * " Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key"
 * " and derives keys from that."
 * ""
 * " Your node_id is seed/0'"
 * " ChannelMonitor closes may use seed/1'"
 * " Cooperative closes may use seed/2'"
 * " The two close keys may be needed to claim on-chain funds!"
 */
typedef struct {
   const LDKlnKeysManager *inner;
} LDKKeysManager;

/**
 * " A trait encapsulating the operations required of a logger"
 */
typedef struct {
   void *this_arg;
   /**
    * " Logs the `Record`"
    */
   void (*log)(const void *this_arg, const char *record);
} LDKLogger;

/**
 * " Manager which keeps track of a number of channels and sends messages to the appropriate"
 * " channel, also tracking HTLC preimages and forwarding onion packets appropriately."
 * ""
 * " Implements ChannelMessageHandler, handling the multi-channel parts and passing things through"
 * " to individual Channels."
 * ""
 * " Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for"
 * " all peers during write/read (though does not modify this instance, only the instance being"
 * " serialized). This will result in any channels which have not yet exchanged funding_created (ie"
 * " called funding_transaction_generated for outbound channels)."
 * ""
 * " Note that you can be a bit lazier about writing out ChannelManager than you can be with"
 * " ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before"
 * " returning from ManyChannelMonitor::add_/update_monitor, with ChannelManagers, writing updates"
 * " happens out-of-band (and will prevent any other ChannelManager operations from occurring during"
 * " the serialization process). If the deserialized version is out-of-date compared to the"
 * " ChannelMonitors passed by reference to read(), those channels will be force-closed based on the"
 * " ChannelMonitor state and no funds will be lost (mod on-chain transaction fees)."
 * ""
 * " Note that the deserializer is only implemented for (Sha256dHash, ChannelManager), which"
 * " tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along"
 * " the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call"
 * " block_connected() to step towards your best block) upon deserialization before using the"
 * " object!"
 * ""
 * " Note that ChannelManager is responsible for tracking liveness of its channels and generating"
 * " ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid"
 * " spam due to quick disconnection/reconnection, updates are not sent until the channel has been"
 * " offline for a full minute. In order to track this, you must call"
 * " timer_chan_freshness_every_min roughly once per minute, though it doesn't have to be perfect."
 * ""
 * " Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager"
 * " a SimpleRefChannelManager, for conciseness. See their documentation for more details, but"
 * " essentially you should default to using a SimpleRefChannelManager, and use a"
 * " SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when"
 * " you're using lightning-net-tokio."
 */
typedef struct {
   const LDKlnChannelManager *inner;
} LDKChannelManager;

/**
 * " Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels"
 */
typedef struct {
   const LDKlnChannelDetails *inner;
} LDKChannelDetails;

typedef struct {
   uint8_t compressed_form[33];
} LDKPublicKey;

/**
 * " Features used within an `init` message."
 */
typedef struct {
   const LDKlnInitFeatures *inner;
} LDKInitFeatures;

/**
 * " If a payment fails to send, it can be in one of several states. This enum is returned as the"
 * " Err() type describing which state the payment is in, see the description of individual enum"
 * " states for more."
 */
typedef struct {
   const LDKlnPaymentSendFailure *inner;
} LDKPaymentSendFailure;

/**
 * " A trait which should be implemented to provide feerate information on a number of time"
 * " horizons."
 * ""
 * " Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're"
 * " called from inside the library in response to ChainListener events, P2P events, or timer"
 * " events)."
 */
typedef struct {
   void *this_arg;
   /**
    * " Gets estimated satoshis of fee required per 1000 Weight-Units."
    * ""
    * " Must be no smaller than 253 (ie 1 satoshi-per-byte rounded up to ensure later round-downs"
    * " don't put us below 1 satoshi-per-byte)."
    * ""
    * " This translates to:"
    * "  * satoshis-per-byte * 250"
    * "  * ceil(satoshis-per-kbyte / 4)"
    */
   uint64_t (*get_est_sat_per_1000_weight)(const void *this_arg, LDKConfirmationTarget confirmation_target);
} LDKFeeEstimator;

/**
 * " Simple trait indicating ability to track a set of ChannelMonitors and multiplex events between"
 * " them. Generally should be implemented by keeping a local SimpleManyChannelMonitor and passing"
 * " events to it, while also taking any add/update_monitor events and passing them to some remote"
 * " server(s)."
 * ""
 * " In general, you must always have at least one local copy in memory, which must never fail to"
 * " update (as it is responsible for broadcasting the latest state in case the channel is closed),"
 * " and then persist it to various on-disk locations. If, for some reason, the in-memory copy fails"
 * " to update (eg out-of-memory or some other condition), you must immediately shut down without"
 * " taking any further action such as writing the current state to disk. This should likely be"
 * " accomplished via panic!() or abort()."
 * ""
 * " Note that any updates to a channel's monitor *must* be applied to each instance of the"
 * " channel's monitor everywhere (including remote watchtowers) *before* this function returns. If"
 * " an update occurs and a remote watchtower is left with old state, it may broadcast transactions"
 * " which we have revoked, allowing our counterparty to claim all funds in the channel!"
 * ""
 * " User needs to notify implementors of ManyChannelMonitor when a new block is connected or"
 * " disconnected using their `block_connected` and `block_disconnected` methods. However, rather"
 * " than calling these methods directly, the user should register implementors as listeners to the"
 * " BlockNotifier and call the BlockNotifier's `block_(dis)connected` methods, which will notify"
 * " all registered listeners in one go."
 */
typedef struct {
   void *this_arg;
} LDKManyChannelMonitor;

typedef struct {
   const uint8_t *data;
   uintptr_t datalen;
} LDKTransaction;

/**
 * " An interface to send a transaction to the Bitcoin network."
 */
typedef struct {
   void *this_arg;
   /**
    * " Sends a transaction out to (hopefully) be mined."
    */
   void (*broadcast_transaction)(const void *this_arg, LDKTransaction tx);
} LDKBroadcasterInterface;

typedef struct {
   uint8_t bytes[32];
} LDKSecretKey;

typedef struct {
   const uint8_t *data;
   uintptr_t datalen;
} LDKScript;

/**
 * " A trait to describe an object which can get user secrets and key material."
 */
typedef struct {
   void *this_arg;
   /**
    * " Get node secret key (aka node_id or network_key)"
    */
   LDKSecretKey (*get_node_secret)(const void *this_arg);
   /**
    * " Get destination redeemScript to encumber static protocol exit points."
    */
   LDKScript (*get_destination_script)(const void *this_arg);
   /**
    * " Get shutdown_pubkey to use as PublicKey at channel closure"
    */
   LDKPublicKey (*get_shutdown_pubkey)(const void *this_arg);
   /**
    * " Get a unique temporary channel id. Channels will be referred to by this until the funding"
    * " transaction is created, at which point they will use the outpoint in the funding"
    * " transaction."
    */
   LDKThirtyTwoBytes (*get_channel_id)(const void *this_arg);
} LDKKeysInterface;

/**
 * " An update generated by the underlying Channel itself which contains some new information the"
 * " ChannelMonitor should be made aware of."
 */
typedef struct {
   const LDKlnChannelMonitorUpdate *inner;
} LDKChannelMonitorUpdate;

/**
 * " General Err type for ChannelMonitor actions. Generally, this implies that the data provided is"
 * " inconsistent with the ChannelMonitor being called. eg for ChannelMonitor::update_monitor this"
 * " means you tried to update a monitor for a different channel or the ChannelMonitorUpdate was"
 * " corrupted."
 * " Contains a human-readable error message."
 */
typedef struct {
   const LDKlnMonitorUpdateError *inner;
} LDKMonitorUpdateError;

/**
 * " Simple structure send back by ManyChannelMonitor in case of HTLC detected onchain from a"
 * " forward channel and from which info are needed to update HTLC in a backward channel."
 */
typedef struct {
   const LDKlnHTLCUpdate *inner;
} LDKHTLCUpdate;

/**
 * " A ChannelMonitor handles chain events (blocks connected and disconnected) and generates"
 * " on-chain transactions to ensure no loss of funds occurs."
 * ""
 * " You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date"
 * " information and are actively monitoring the chain."
 * ""
 * " Pending Events or updated HTLCs which have not yet been read out by"
 * " get_and_clear_pending_htlcs_updated or get_and_clear_pending_events are serialized to disk and"
 * " reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events"
 * " gotten are fully handled before re-serializing the new state."
 */
typedef struct {
   const LDKlnChannelMonitor *inner;
} LDKChannelMonitor;

/**
 * " An error in decoding a message or struct."
 */
typedef struct {
   const LDKlnDecodeError *inner;
} LDKDecodeError;

/**
 * " An init message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnInit *inner;
} LDKInit;

/**
 * " An error message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnErrorMessage *inner;
} LDKErrorMessage;

/**
 * " A ping message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnPing *inner;
} LDKPing;

/**
 * " A pong message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnPong *inner;
} LDKPong;

/**
 * " An open_channel message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnOpenChannel *inner;
} LDKOpenChannel;

/**
 * " An accept_channel message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnAcceptChannel *inner;
} LDKAcceptChannel;

/**
 * " A funding_created message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnFundingCreated *inner;
} LDKFundingCreated;

/**
 * " A funding_signed message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnFundingSigned *inner;
} LDKFundingSigned;

/**
 * " A funding_locked message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnFundingLocked *inner;
} LDKFundingLocked;

/**
 * " A shutdown message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnShutdown *inner;
} LDKShutdown;

/**
 * " A closing_signed message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnClosingSigned *inner;
} LDKClosingSigned;

/**
 * " An update_add_htlc message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateAddHTLC *inner;
} LDKUpdateAddHTLC;

/**
 * " An update_fulfill_htlc message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateFulfillHTLC *inner;
} LDKUpdateFulfillHTLC;

/**
 * " An update_fail_htlc message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateFailHTLC *inner;
} LDKUpdateFailHTLC;

/**
 * " An update_fail_malformed_htlc message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateFailMalformedHTLC *inner;
} LDKUpdateFailMalformedHTLC;

/**
 * " A commitment_signed message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnCommitmentSigned *inner;
} LDKCommitmentSigned;

/**
 * " A revoke_and_ack message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnRevokeAndACK *inner;
} LDKRevokeAndACK;

/**
 * " An update_fee message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnUpdateFee *inner;
} LDKUpdateFee;

/**
 * " A channel_reestablish message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnChannelReestablish *inner;
} LDKChannelReestablish;

/**
 * " An announcement_signatures message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnAnnouncementSignatures *inner;
} LDKAnnouncementSignatures;

/**
 * " An address which can be used to connect to a remote peer"
 */
typedef struct {
   const LDKlnNetAddress *inner;
} LDKNetAddress;

/**
 * " The unsigned part of a node_announcement"
 */
typedef struct {
   const LDKlnUnsignedNodeAnnouncement *inner;
} LDKUnsignedNodeAnnouncement;

/**
 * " A node_announcement message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnNodeAnnouncement *inner;
} LDKNodeAnnouncement;

/**
 * " The unsigned part of a channel_announcement"
 */
typedef struct {
   const LDKlnUnsignedChannelAnnouncement *inner;
} LDKUnsignedChannelAnnouncement;

/**
 * " A channel_announcement message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnChannelAnnouncement *inner;
} LDKChannelAnnouncement;

/**
 * " A channel_update message to be sent or received from a peer"
 */
typedef struct {
   const LDKlnChannelUpdate *inner;
} LDKChannelUpdate;

/**
 * " An Err type for failure to process messages."
 */
typedef struct {
   const LDKlnLightningError *inner;
} LDKLightningError;

/**
 * " Struct used to return values from revoke_and_ack messages, containing a bunch of commitment"
 * " transaction updates if they were pending."
 */
typedef struct {
   const LDKlnCommitmentUpdate *inner;
} LDKCommitmentUpdate;

/**
 * " The information we received from a peer along the route of a payment we originated. This is"
 * " returned by ChannelMessageHandler::handle_update_fail_htlc to be passed into"
 * " RoutingMessageHandler::handle_htlc_fail_channel_update to update our network map."
 */
typedef struct {
   const LDKlnHTLCFailChannelUpdate *inner;
} LDKHTLCFailChannelUpdate;

/**
 * " Provides references to trait impls which handle different types of messages."
 */
typedef struct {
   const LDKlnMessageHandler *inner;
} LDKMessageHandler;

/**
 * " A trait indicating an object may generate message send events"
 */
typedef struct {
   void *this_arg;
} LDKMessageSendEventsProvider;

/**
 * " A trait to describe an object which can receive channel messages."
 * ""
 * " Messages MAY be called in parallel when they originate from different their_node_ids, however"
 * " they MUST NOT be called in parallel when the two calls have the same their_node_id."
 */
typedef struct {
   void *this_arg;
   /**
    * " Handle an incoming open_channel message from the given peer."
    */
   void (*handle_open_channel)(const void *this_arg, LDKPublicKey their_node_id, LDKInitFeatures their_features, const LDKOpenChannel *msg);
   /**
    * " Handle an incoming accept_channel message from the given peer."
    */
   void (*handle_accept_channel)(const void *this_arg, LDKPublicKey their_node_id, LDKInitFeatures their_features, const LDKAcceptChannel *msg);
   /**
    * " Handle an incoming funding_created message from the given peer."
    */
   void (*handle_funding_created)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingCreated *msg);
   /**
    * " Handle an incoming funding_signed message from the given peer."
    */
   void (*handle_funding_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingSigned *msg);
   /**
    * " Handle an incoming funding_locked message from the given peer."
    */
   void (*handle_funding_locked)(const void *this_arg, LDKPublicKey their_node_id, const LDKFundingLocked *msg);
   /**
    * " Handle an incoming shutdown message from the given peer."
    */
   void (*handle_shutdown)(const void *this_arg, LDKPublicKey their_node_id, const LDKShutdown *msg);
   /**
    * " Handle an incoming closing_signed message from the given peer."
    */
   void (*handle_closing_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKClosingSigned *msg);
   /**
    * " Handle an incoming update_add_htlc message from the given peer."
    */
   void (*handle_update_add_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateAddHTLC *msg);
   /**
    * " Handle an incoming update_fulfill_htlc message from the given peer."
    */
   void (*handle_update_fulfill_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFulfillHTLC *msg);
   /**
    * " Handle an incoming update_fail_htlc message from the given peer."
    */
   void (*handle_update_fail_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFailHTLC *msg);
   /**
    * " Handle an incoming update_fail_malformed_htlc message from the given peer."
    */
   void (*handle_update_fail_malformed_htlc)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFailMalformedHTLC *msg);
   /**
    * " Handle an incoming commitment_signed message from the given peer."
    */
   void (*handle_commitment_signed)(const void *this_arg, LDKPublicKey their_node_id, const LDKCommitmentSigned *msg);
   /**
    * " Handle an incoming revoke_and_ack message from the given peer."
    */
   void (*handle_revoke_and_ack)(const void *this_arg, LDKPublicKey their_node_id, const LDKRevokeAndACK *msg);
   /**
    * " Handle an incoming update_fee message from the given peer."
    */
   void (*handle_update_fee)(const void *this_arg, LDKPublicKey their_node_id, const LDKUpdateFee *msg);
   /**
    * " Handle an incoming announcement_signatures message from the given peer."
    */
   void (*handle_announcement_signatures)(const void *this_arg, LDKPublicKey their_node_id, const LDKAnnouncementSignatures *msg);
   /**
    * " Indicates a connection to the peer failed/an existing connection was lost. If no connection"
    * " is believed to be possible in the future (eg they're sending us messages we don't"
    * " understand or indicate they require unknown feature bits), no_connection_possible is set"
    * " and any outstanding channels should be failed."
    */
   void (*peer_disconnected)(const void *this_arg, LDKPublicKey their_node_id, bool no_connection_possible);
   /**
    * " Handle a peer reconnecting, possibly generating channel_reestablish message(s)."
    */
   void (*peer_connected)(const void *this_arg, LDKPublicKey their_node_id, const LDKInit *msg);
   /**
    * " Handle an incoming channel_reestablish message from the given peer."
    */
   void (*handle_channel_reestablish)(const void *this_arg, LDKPublicKey their_node_id, const LDKChannelReestablish *msg);
   /**
    * " Handle an incoming error message from the given peer."
    */
   void (*handle_error)(const void *this_arg, LDKPublicKey their_node_id, const LDKErrorMessage *msg);
   LDKMessageSendEventsProvider MessageSendEventsProvider;
} LDKChannelMessageHandler;

/**
 * " A trait to describe an object which can receive routing messages."
 */
typedef struct {
   void *this_arg;
   /**
    * " Returns whether a full sync should be requested from a peer."
    */
   bool (*should_request_full_sync)(const void *this_arg, LDKPublicKey node_id);
} LDKRoutingMessageHandler;

/**
 * " Error for PeerManager errors. If you get one of these, you must disconnect the socket and"
 * " generate no further read_event/write_buffer_space_avail calls for the descriptor, only"
 * " triggering a single socket_disconnected call (unless it was provided in response to a"
 * " new_*_connection event, in which case no such socket_disconnected() must be called and the"
 * " socket silently disconencted)."
 */
typedef struct {
   const LDKlnPeerHandleError *inner;
} LDKPeerHandleError;

/**
 * " A PeerManager manages a set of peers, described by their SocketDescriptor and marshalls socket"
 * " events into messages which it passes on to its MessageHandlers."
 * ""
 * " Rather than using a plain PeerManager, it is preferable to use either a SimpleArcPeerManager"
 * " a SimpleRefPeerManager, for conciseness. See their documentation for more details, but"
 * " essentially you should default to using a SimpleRefPeerManager, and use a"
 * " SimpleArcPeerManager when you require a PeerManager with a static lifetime, such as when"
 * " you're using lightning-net-tokio."
 */
typedef struct {
   const LDKlnPeerManager *inner;
} LDKPeerManager;

typedef struct {
   const uint8_t *data;
   uintptr_t datalen;
} LDKu8slice;

/**
 * " Provides an object which can be used to send data to and which uniquely identifies a connection"
 * " to a remote host. You will need to be able to generate multiple of these which meet Eq and"
 * " implement Hash to meet the PeerManager API."
 * ""
 * " For efficiency, Clone should be relatively cheap for this type."
 * ""
 * " You probably want to just extend an int and put a file descriptor in a struct and implement"
 * " send_data. Note that if you are using a higher-level net library that may call close() itself,"
 * " be careful to ensure you don't have races whereby you might register a new connection with an"
 * " fd which is the same as a previous one which has yet to be removed via"
 * " PeerManager::socket_disconnected()."
 */
typedef struct {
   void *this_arg;
   /**
    * " Attempts to send some data from the given slice to the peer."
    * ""
    * " Returns the amount of data which was sent, possibly 0 if the socket has since disconnected."
    * " Note that in the disconnected case, socket_disconnected must still fire and further write"
    * " attempts may occur until that time."
    * ""
    * " If the returned size is smaller than data.len(), a write_available event must"
    * " trigger the next time more data can be written. Additionally, until the a send_data event"
    * " completes fully, no further read_events should trigger on the same peer!"
    * ""
    * " If a read_event on this descriptor had previously returned true (indicating that read"
    * " events should be paused to prevent DoS in the send buffer), resume_read may be set"
    * " indicating that read events on this descriptor should resume. A resume_read of false does"
    * " *not* imply that further read events should be paused."
    */
   uintptr_t (*send_data)(void *this_arg, LDKu8slice data, bool resume_read);
   /**
    * " Disconnect the socket pointed to by this SocketDescriptor. Once this function returns, no"
    * " more calls to write_buffer_space_avail, read_event or socket_disconnected may be made with"
    * " this descriptor. No socket_disconnected call should be generated as a result of this call,"
    * " though races may occur whereby disconnect_socket is called after a call to"
    * " socket_disconnected but prior to socket_disconnected returning."
    */
   void (*disconnect_socket)(void *this_arg);
   bool (*eq)(const void *this_arg, const void *other_arg);
   uint64_t (*hash)(const void *this_arg);
} LDKSocketDescriptor;

/**
 * " The set of public keys which are used in the creation of one commitment transaction."
 * " These are derived from the channel base keys and per-commitment data."
 */
typedef struct {
   const LDKlnTxCreationKeys *inner;
} LDKTxCreationKeys;

/**
 * " One counterparty's public keys which do not change over the life of a channel."
 */
typedef struct {
   const LDKlnChannelPublicKeys *inner;
} LDKChannelPublicKeys;

/**
 * " Information about an HTLC as it appears in a commitment transaction"
 */
typedef struct {
   const LDKlnHTLCOutputInCommitment *inner;
} LDKHTLCOutputInCommitment;

/**
 * " Features used within a `node_announcement` message."
 */
typedef struct {
   const LDKlnNodeFeatures *inner;
} LDKNodeFeatures;

/**
 * " Features used within a `channel_announcement` message."
 */
typedef struct {
   const LDKlnChannelFeatures *inner;
} LDKChannelFeatures;

void Event_free(LDKEvent this_ptr);

void MessageSendEvent_free(LDKMessageSendEvent this_ptr);

void APIError_free(LDKAPIError this_ptr);

/**
 * " Returns the most verbose logging level."
 */
LDKLevel Level_max(void);

void UserConfig_free(LDKUserConfig this_ptr);

void ChannelHandshakeConfig_free(LDKChannelHandshakeConfig this_ptr);

void ChannelHandshakeConfig_set_minimum_depth(LDKChannelHandshakeConfig *this_ptr, uint32_t val);

void ChannelHandshakeConfig_set_our_to_self_delay(LDKChannelHandshakeConfig *this_ptr, uint16_t val);

void ChannelHandshakeConfig_set_our_htlc_minimum_msat(LDKChannelHandshakeConfig *this_ptr, uint64_t val);

LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg);

void ChannelHandshakeLimits_free(LDKChannelHandshakeLimits this_ptr);

void ChannelHandshakeLimits_set_min_funding_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

void ChannelHandshakeLimits_set_max_htlc_minimum_msat(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

void ChannelHandshakeLimits_set_min_max_accepted_htlcs(LDKChannelHandshakeLimits *this_ptr, uint16_t val);

void ChannelHandshakeLimits_set_min_dust_limit_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

void ChannelHandshakeLimits_set_max_dust_limit_satoshis(LDKChannelHandshakeLimits *this_ptr, uint64_t val);

void ChannelHandshakeLimits_set_max_minimum_depth(LDKChannelHandshakeLimits *this_ptr, uint32_t val);

void ChannelHandshakeLimits_set_force_announced_channel_preference(LDKChannelHandshakeLimits *this_ptr, bool val);

void ChannelHandshakeLimits_set_their_to_self_delay(LDKChannelHandshakeLimits *this_ptr, uint16_t val);

LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint64_t min_dust_limit_satoshis_arg, uint64_t max_dust_limit_satoshis_arg, uint32_t max_minimum_depth_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);

void ChannelConfig_free(LDKChannelConfig this_ptr);

void ChannelConfig_set_fee_proportional_millionths(LDKChannelConfig *this_ptr, uint32_t val);

void ChannelConfig_set_announced_channel(LDKChannelConfig *this_ptr, bool val);

void ChannelConfig_set_commit_upfront_shutdown_pubkey(LDKChannelConfig *this_ptr, bool val);

LDKChannelConfig ChannelConfig_new(uint32_t fee_proportional_millionths_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg);

void OutPoint_free(LDKOutPoint this_ptr);

const uint8_t (*OutPoint_get_txid(const LDKOutPoint *this_ptr))[32];

void OutPoint_set_txid(LDKOutPoint *this_ptr, uint8_t val[32]);

void OutPoint_set_index(LDKOutPoint *this_ptr, uint16_t val);

LDKOutPoint OutPoint_new(uint8_t txid_arg[32], uint16_t index_arg);

/**
 * " Convert an `OutPoint` to a lightning channel id."
 */
LDKThirtyTwoBytes OutPoint_to_channel_id(const LDKOutPoint *this_arg);

void SpendableOutputDescriptor_free(LDKSpendableOutputDescriptor this_ptr);

void InMemoryChannelKeys_free(LDKInMemoryChannelKeys this_ptr);

void KeysManager_free(LDKKeysManager this_ptr);

/**
 * " Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your"
 * " RNG is busted) this may panic (but more importantly, you will possibly lose funds)."
 * " starting_time isn't strictly required to actually be a time, but it must absolutely,"
 * " without a doubt, be unique to this instance. ie if you start multiple times with the same"
 * " seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to"
 * " simply use the current time (with very high precision)."
 * ""
 * " The seed MUST be backed up safely prior to use so that the keys can be re-created, however,"
 * " obviously, starting_time should be unique every time you reload the library - it is only"
 * " used to generate new ephemeral key data (which will be stored by the individual channel if"
 * " necessary)."
 * ""
 * " Note that the seed is required to recover certain on-chain funds independent of"
 * " ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any"
 * " channel, and some on-chain during-closing funds."
 * ""
 * " Note that until the 0.1 release there is no guarantee of backward compatibility between"
 * " versions. Once the library is more fully supported, the docs will be updated to include a"
 * " detailed description of the guarantee."
 */
LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], LDKNetwork network, LDKLogger logger, uint64_t starting_time_secs, uint32_t starting_time_nanos);

void ChannelManager_free(LDKChannelManager this_ptr);

void ChannelDetails_free(LDKChannelDetails this_ptr);

const uint8_t (*ChannelDetails_get_channel_id(const LDKChannelDetails *this_ptr))[32];

void ChannelDetails_set_channel_id(LDKChannelDetails *this_ptr, LDKThirtyTwoBytes val);

LDKPublicKey ChannelDetails_get_remote_network_id(const LDKChannelDetails *this_ptr);

void ChannelDetails_set_remote_network_id(LDKChannelDetails *this_ptr, LDKPublicKey val);

const LDKInitFeatures *ChannelDetails_get_counterparty_features(const LDKChannelDetails *this_ptr);

void ChannelDetails_set_counterparty_features(LDKChannelDetails *this_ptr, LDKInitFeatures val);

void ChannelDetails_set_channel_value_satoshis(LDKChannelDetails *this_ptr, uint64_t val);

void ChannelDetails_set_user_id(LDKChannelDetails *this_ptr, uint64_t val);

void ChannelDetails_set_outbound_capacity_msat(LDKChannelDetails *this_ptr, uint64_t val);

void ChannelDetails_set_inbound_capacity_msat(LDKChannelDetails *this_ptr, uint64_t val);

void ChannelDetails_set_is_live(LDKChannelDetails *this_ptr, bool val);

void PaymentSendFailure_free(LDKPaymentSendFailure this_ptr);

/**
 * " Constructs a new ChannelManager to hold several channels and route between them."
 * ""
 * " This is the main \"logic hub\" for all channel-related actions, and implements"
 * " ChannelMessageHandler."
 * ""
 * " Non-proportional fees are fixed according to our risk using the provided fee estimator."
 * ""
 * " panics if channel_value_satoshis is >= `MAX_FUNDING_SATOSHIS`!"
 * ""
 * " Users must provide the current blockchain height from which to track onchain channel"
 * " funding outpoints and send payments with reliable timelocks."
 * ""
 * " Users need to notify the new ChannelManager when a new block is connected or"
 * " disconnected using its `block_connected` and `block_disconnected` methods."
 * " However, rather than calling these methods directly, the user should register"
 * " the ChannelManager as a listener to the BlockNotifier and call the BlockNotifier's"
 * " `block_(dis)connected` methods, which will notify all registered listeners in one"
 * " go."
 */
LDKChannelManager ChannelManager_new(LDKNetwork network, LDKFeeEstimator fee_est, LDKManyChannelMonitor monitor, LDKBroadcasterInterface tx_broadcaster, LDKLogger logger, LDKKeysInterface keys_manager, LDKUserConfig config, uintptr_t current_blockchain_height);

/**
 * " Force closes a channel, immediately broadcasting the latest local commitment transaction to"
 * " the chain and rejecting new HTLCs on the given channel."
 */
void ChannelManager_force_close_channel(const LDKChannelManager *this_arg, const uint8_t (*channel_id)[32]);

/**
 * " Force close all channels, immediately broadcasting the latest local commitment transaction"
 * " for each to the chain and rejecting new HTLCs on each."
 */
void ChannelManager_force_close_all_channels(const LDKChannelManager *this_arg);

/**
 * " Processes HTLCs which are pending waiting on random forward delay."
 * ""
 * " Should only really ever be called in response to a PendingHTLCsForwardable event."
 * " Will likely generate further events."
 */
void ChannelManager_process_pending_htlc_forwards(const LDKChannelManager *this_arg);

/**
 * " If a peer is disconnected we mark any channels with that peer as 'disabled'."
 * " After some time, if channels are still disabled we need to broadcast a ChannelUpdate"
 * " to inform the network about the uselessness of these channels."
 * ""
 * " This method handles all the details, and must be called roughly once per minute."
 */
void ChannelManager_timer_chan_freshness_every_min(const LDKChannelManager *this_arg);

/**
 * " Gets the node_id held by this ChannelManager"
 */
LDKPublicKey ChannelManager_get_our_node_id(const LDKChannelManager *this_arg);

void ChannelMonitorUpdate_free(LDKChannelMonitorUpdate this_ptr);

void ChannelMonitorUpdate_set_update_id(LDKChannelMonitorUpdate *this_ptr, uint64_t val);

void MonitorUpdateError_free(LDKMonitorUpdateError this_ptr);

void HTLCUpdate_free(LDKHTLCUpdate this_ptr);

void ChannelMonitor_free(LDKChannelMonitor this_ptr);

/**
 * " Gets the update_id from the latest ChannelMonitorUpdate which was applied to this"
 * " ChannelMonitor."
 */
uint64_t ChannelMonitor_get_latest_update_id(const LDKChannelMonitor *this_arg);

void DecodeError_free(LDKDecodeError this_ptr);

void Init_free(LDKInit this_ptr);

void ErrorMessage_free(LDKErrorMessage this_ptr);

void Ping_free(LDKPing this_ptr);

void Pong_free(LDKPong this_ptr);

void OpenChannel_free(LDKOpenChannel this_ptr);

void AcceptChannel_free(LDKAcceptChannel this_ptr);

void FundingCreated_free(LDKFundingCreated this_ptr);

void FundingSigned_free(LDKFundingSigned this_ptr);

void FundingLocked_free(LDKFundingLocked this_ptr);

const uint8_t (*FundingLocked_get_channel_id(const LDKFundingLocked *this_ptr))[32];

void FundingLocked_set_channel_id(LDKFundingLocked *this_ptr, LDKThirtyTwoBytes val);

LDKPublicKey FundingLocked_get_next_per_commitment_point(const LDKFundingLocked *this_ptr);

void FundingLocked_set_next_per_commitment_point(LDKFundingLocked *this_ptr, LDKPublicKey val);

LDKFundingLocked FundingLocked_new(LDKThirtyTwoBytes channel_id_arg, LDKPublicKey next_per_commitment_point_arg);

void Shutdown_free(LDKShutdown this_ptr);

void ClosingSigned_free(LDKClosingSigned this_ptr);

void UpdateAddHTLC_free(LDKUpdateAddHTLC this_ptr);

void UpdateFulfillHTLC_free(LDKUpdateFulfillHTLC this_ptr);

void UpdateFailHTLC_free(LDKUpdateFailHTLC this_ptr);

void UpdateFailMalformedHTLC_free(LDKUpdateFailMalformedHTLC this_ptr);

void CommitmentSigned_free(LDKCommitmentSigned this_ptr);

void RevokeAndACK_free(LDKRevokeAndACK this_ptr);

void UpdateFee_free(LDKUpdateFee this_ptr);

void ChannelReestablish_free(LDKChannelReestablish this_ptr);

void AnnouncementSignatures_free(LDKAnnouncementSignatures this_ptr);

void NetAddress_free(LDKNetAddress this_ptr);

void UnsignedNodeAnnouncement_free(LDKUnsignedNodeAnnouncement this_ptr);

LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const LDKUnsignedNodeAnnouncement *this_ptr);

void UnsignedNodeAnnouncement_set_node_id(LDKUnsignedNodeAnnouncement *this_ptr, LDKPublicKey val);

void NodeAnnouncement_free(LDKNodeAnnouncement this_ptr);

void UnsignedChannelAnnouncement_free(LDKUnsignedChannelAnnouncement this_ptr);

LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const LDKUnsignedChannelAnnouncement *this_ptr);

void UnsignedChannelAnnouncement_set_node_id_1(LDKUnsignedChannelAnnouncement *this_ptr, LDKPublicKey val);

LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const LDKUnsignedChannelAnnouncement *this_ptr);

void UnsignedChannelAnnouncement_set_node_id_2(LDKUnsignedChannelAnnouncement *this_ptr, LDKPublicKey val);

void ChannelAnnouncement_free(LDKChannelAnnouncement this_ptr);

void ChannelUpdate_free(LDKChannelUpdate this_ptr);

void LightningError_free(LDKLightningError this_ptr);

void CommitmentUpdate_free(LDKCommitmentUpdate this_ptr);

const LDKCommitmentSigned *CommitmentUpdate_get_commitment_signed(const LDKCommitmentUpdate *this_ptr);

void CommitmentUpdate_set_commitment_signed(LDKCommitmentUpdate *this_ptr, LDKCommitmentSigned val);

void HTLCFailChannelUpdate_free(LDKHTLCFailChannelUpdate this_ptr);

void MessageHandler_free(LDKMessageHandler this_ptr);

const LDKChannelMessageHandler *MessageHandler_get_chan_handler(const LDKMessageHandler *this_ptr);

void MessageHandler_set_chan_handler(LDKMessageHandler *this_ptr, LDKChannelMessageHandler val);

const LDKRoutingMessageHandler *MessageHandler_get_route_handler(const LDKMessageHandler *this_ptr);

void MessageHandler_set_route_handler(LDKMessageHandler *this_ptr, LDKRoutingMessageHandler val);

LDKMessageHandler MessageHandler_new(LDKChannelMessageHandler chan_handler_arg, LDKRoutingMessageHandler route_handler_arg);

void PeerHandleError_free(LDKPeerHandleError this_ptr);

void PeerManager_free(LDKPeerManager this_ptr);

/**
 * " Constructs a new PeerManager with the given message handlers and node_id secret key"
 * " ephemeral_random_data is used to derive per-connection ephemeral keys and must be"
 * " cryptographically secure random bytes."
 */
LDKPeerManager PeerManager_new(LDKMessageHandler message_handler, LDKSecretKey our_node_secret, const uint8_t (*ephemeral_random_data)[32], LDKLogger logger);

/**
 * " Checks for any events generated by our handlers and processes them. Includes sending most"
 * " response messages as well as messages generated by calls to handler functions directly (eg"
 * " functions like ChannelManager::process_pending_htlc_forward or send_payment)."
 */
void PeerManager_process_events(const LDKPeerManager *this_arg);

/**
 * " Indicates that the given socket descriptor's connection is now closed."
 * ""
 * " This must only be called if the socket has been disconnected by the peer or your own"
 * " decision to disconnect it and must NOT be called in any case where other parts of this"
 * " library (eg PeerHandleError, explicit disconnect_socket calls) instruct you to disconnect"
 * " the peer."
 * ""
 * " Panics if the descriptor was not previously registered in a successful new_*_connection event."
 */
void PeerManager_socket_disconnected(const LDKPeerManager *this_arg, const LDKSocketDescriptor *descriptor);

/**
 * " This function should be called roughly once every 30 seconds."
 * " It will send pings to each peer and disconnect those which did not respond to the last round of pings."
 * " Will most likely call send_data on all of the registered descriptors, thus, be very careful with reentrancy issues!"
 */
void PeerManager_timer_tick_occured(const LDKPeerManager *this_arg);

void TxCreationKeys_free(LDKTxCreationKeys this_ptr);

LDKPublicKey TxCreationKeys_get_per_commitment_point(const LDKTxCreationKeys *this_ptr);

void TxCreationKeys_set_per_commitment_point(LDKTxCreationKeys *this_ptr, LDKPublicKey val);

void ChannelPublicKeys_free(LDKChannelPublicKeys this_ptr);

LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const LDKChannelPublicKeys *this_ptr);

void ChannelPublicKeys_set_funding_pubkey(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const LDKChannelPublicKeys *this_ptr);

void ChannelPublicKeys_set_revocation_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

LDKPublicKey ChannelPublicKeys_get_payment_point(const LDKChannelPublicKeys *this_ptr);

void ChannelPublicKeys_set_payment_point(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const LDKChannelPublicKeys *this_ptr);

void ChannelPublicKeys_set_delayed_payment_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const LDKChannelPublicKeys *this_ptr);

void ChannelPublicKeys_set_htlc_basepoint(LDKChannelPublicKeys *this_ptr, LDKPublicKey val);

LDKChannelPublicKeys ChannelPublicKeys_new(LDKPublicKey funding_pubkey_arg, LDKPublicKey revocation_basepoint_arg, LDKPublicKey payment_point_arg, LDKPublicKey delayed_payment_basepoint_arg, LDKPublicKey htlc_basepoint_arg);

void HTLCOutputInCommitment_free(LDKHTLCOutputInCommitment this_ptr);

void HTLCOutputInCommitment_set_offered(LDKHTLCOutputInCommitment *this_ptr, bool val);

void HTLCOutputInCommitment_set_amount_msat(LDKHTLCOutputInCommitment *this_ptr, uint64_t val);

void HTLCOutputInCommitment_set_cltv_expiry(LDKHTLCOutputInCommitment *this_ptr, uint32_t val);

void InitFeatures_free(LDKInitFeatures this_ptr);

void NodeFeatures_free(LDKNodeFeatures this_ptr);

void ChannelFeatures_free(LDKChannelFeatures this_ptr);

/* Text to put at the end of the generated file */
